<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>WRXinYue's Blog</title><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search the blog","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script>mermaid.initialize({
 startOnLoad: true
 , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.6.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><ol class="navContent"><li class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search the blog" spellcheck="false" maxlength="50" type="text" id="search-input"></span></li><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/contact/"><span class="navItemTitle">Contact</span></a></li></ol></nav><div class="search-popup"><div id="search-result"></div></div></header><article><div id="post-bg"><div id="post-title"><h1></h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2022-08-25T07:26:16.439Z" id="date"> 2022-08-25</time></div></span><br><span>Last Update: <div class="control"><time datetime="2022-06-23T06:52:59.000Z" id="updated"> 2022-06-23</time></div></span></div></div><hr><div id="post-content"><p>Unity3D</p>
<p>技术学习之自由视角下的角色控制</p>
<p>今天呢，我们继续来探讨</p>
<p>Unity3D</p>
<p>角色控制的内容，今天博主将解决在上一篇文章中</p>
<p>没有解决的问题，即自由视角下的角色控制。如图是博主非常喜欢的《古剑奇谭》游戏截</p>
<p>图，在这款游戏中就使用了博主今天要讲解的自由视角，所谓自由视角是指玩家可以按照</p>
<p>自身坐标系向着四个不同的方向移动，当玩家按下鼠标右键时，可以绕</p>
<p>Y</p>
<p>轴按照一定的角</p>
<p>度旋转摄像机，在旋转的过程中，角色将旋转相应的角度。在移动的过程中，摄像机会保</p>
<p>持与玩家间的一定距离，然后跟随角色进行移动。好了，下面我们正式开始今天的内容吧！</p>
<p>在开始今天的内容前，首先让我们来学习下</p>
<p>Unity3D</p>
<p>中较为重要的一部分知识，理解这</p>
<p>些知识是我们开始学习今天内容的基础。</p>
<p>@宫古s驰月资料</p>
<p>@宫古s驰月资料</p>
<p>Unity3D</p>
<p>技术学习之自由视角下的角色控制</p>
<p>今天呢，我们继续来探讨</p>
<p>Unity3D</p>
<p>角色控制的内容，今天博主将解决在上一篇文章中</p>
<p>没有解决的问题，即自由视角下的角色控制。如图是博主非常喜欢的《古剑奇谭》游戏截</p>
<p>图，在这款游戏中就使用了博主今天要讲解的自由视角，所谓自由视角是指玩家可以按照</p>
<p>自身坐标系向着四个不同的方向移动，当玩家按下鼠标右键时，可以绕</p>
<p>Y</p>
<p>轴按照一定的角</p>
<p>度旋转摄像机，在旋转的过程中，角色将旋转相应的角度。在移动的过程中，摄像机会保</p>
<p>持与玩家间的一定距离，然后跟随角色进行移动。好了，下面我们正式开始今天的内容吧！</p>
<p>在开始今天的内容前，首先让我们来学习下</p>
<p>Unity3D</p>
<p>中较为重要的一部分知识，理解这</p>
<p>些知识是我们开始学习今天内容的基础。</p>
<p>@宫古s驰月资料</p>
<p>1</p>
<p>、</p>
<p>Input.GetAxis():</p>
<p>该方法用于在</p>
<p>Unity3D</p>
<p>中根据坐标轴名称返回虚拟坐标系中的值，</p>
<p>通常情况下，使用控制器和键盘输入时此值范围在</p>
<p>-1</p>
<p>到</p>
<p>1</p>
<p>之间。这段话怎么理解呢？我们</p>
<p>来看下面这段脚本：</p>
<p>using UnityEngine;</p>
<p>using System.Collections;</p>
<p>public class example : MonoBehaviour {</p>
<p>&#x2F;&#x2F;</p>
<p>水平速度</p>
<p>public float HorizontalSpeed &#x3D; 2.0F;</p>
<p>&#x2F;&#x2F;</p>
<p>垂直速度</p>
<p>public float VerticalSpeed &#x3D; 2.0F;</p>
<p>void Update()</p>
<p>{</p>
<p>&#x2F;&#x2F;</p>
<p>水平方向</p>
<p>float h &#x3D; HorizontalSpeed * Input.GetAxis(“Mouse X”);</p>
<p>&#x2F;&#x2F;</p>
<p>垂直方向</p>
<p>float v &#x3D; VerticalSpeed * Input.GetAxis(“Mouse Y”);</p>
<p>&#x2F;&#x2F;</p>
<p>旋转</p>
<p>transform.Rotate(v, h, 0);</p>
<p>}</p>
<p>}</p>
<p>这段脚本呢是根据鼠标的位置来旋转物体从而实现对物体的观察，从这段脚本中我们可</p>
<p>以看出，通过获取输入轴的办法，我们可以获得鼠标移动的方向进而实现对于物体的旋转</p>
<p>控制。在</p>
<p>Unity3D</p>
<p>中我们可以通过</p>
<p>Edit-&gt;Project Setting-&gt;Input</p>
<p>来查看项目中的坐标轴名</p>
<p>称：</p>
<p>@宫古s驰月资料</p>
<p>@宫古s驰月资料</p>
<p>1</p>
<p>、</p>
<p>Input.GetAxis():</p>
<p>该方法用于在</p>
<p>Unity3D</p>
<p>中根据坐标轴名称返回虚拟坐标系中的值，</p>
<p>通常情况下，使用控制器和键盘输入时此值范围在</p>
<p>-1</p>
<p>到</p>
<p>1</p>
<p>之间。这段话怎么理解呢？我们</p>
<p>来看下面这段脚本：</p>
<p>using UnityEngine;</p>
<p>using System.Collections;</p>
<p>public class example : MonoBehaviour {</p>
<p>&#x2F;&#x2F;</p>
<p>水平速度</p>
<p>public float HorizontalSpeed &#x3D; 2.0F;</p>
<p>&#x2F;&#x2F;</p>
<p>垂直速度</p>
<p>public float VerticalSpeed &#x3D; 2.0F;</p>
<p>void Update()</p>
<p>{</p>
<p>&#x2F;&#x2F;</p>
<p>水平方向</p>
<p>float h &#x3D; HorizontalSpeed * Input.GetAxis(“Mouse X”);</p>
<p>&#x2F;&#x2F;</p>
<p>垂直方向</p>
<p>float v &#x3D; VerticalSpeed * Input.GetAxis(“Mouse Y”);</p>
<p>&#x2F;&#x2F;</p>
<p>旋转</p>
<p>transform.Rotate(v, h, 0);</p>
<p>}</p>
<p>}</p>
<p>这段脚本呢是根据鼠标的位置来旋转物体从而实现对物体的观察，从这段脚本中我们可</p>
<p>以看出，通过获取输入轴的办法，我们可以获得鼠标移动的方向进而实现对于物体的旋转</p>
<p>控制。在</p>
<p>Unity3D</p>
<p>中我们可以通过</p>
<p>Edit-&gt;Project Setting-&gt;Input</p>
<p>来查看项目中的坐标轴名</p>
<p>称：</p>
<p>@宫古s驰月资料</p>
<p>在后面，我们还将使用这种方式，大家可以对这个方法有进一步的了解。</p>
<p>文章出处【狗刨学习网】</p>
<p>2</p>
<p>、欧拉角</p>
<p>eulerAngles</p>
<p>：</p>
<p>该值是</p>
<p>Vector3</p>
<p>类型的值，</p>
<p>x</p>
<p>、</p>
<p>y</p>
<p>、</p>
<p>z</p>
<p>分别代表绕</p>
<p>x</p>
<p>轴</p>
<p>旋</p>
<p>转</p>
<p>x</p>
<p>度，绕</p>
<p>y</p>
<p>轴</p>
<p>旋</p>
<p>转</p>
<p>y</p>
<p>度</p>
<p>，</p>
<p>绕</p>
<p>z</p>
<p>轴旋转</p>
<p>z</p>
<p>度。因此，该值最为直观的形式是可以允许我们直接</p>
<p>以一个三维向量的形式来修改一个物体的角度，例如下面的脚本：</p>
<p>float mY &#x3D; 5.0;</p>
<p>void Update ()</p>
<p>{</p>
<p>mY +&#x3D; Input.GetAxis(“Horizontal”);</p>
<p>transform.eulerAngles &#x3D;new Vector3(0,mY, 0);</p>
<p>}</p>
<p>@宫古s驰月资料</p>
<p>@宫古s驰月资料</p>
<p>在后面，我们还将使用这种方式，大家可以对这个方法有进一步的了解。</p>
<p>文章出处【狗刨学习网】</p>
<p>2</p>
<p>、欧拉角</p>
<p>eulerAngles</p>
<p>：</p>
<p>该值是</p>
<p>Vector3</p>
<p>类型的值，</p>
<p>x</p>
<p>、</p>
<p>y</p>
<p>、</p>
<p>z</p>
<p>分别代表绕</p>
<p>x</p>
<p>轴</p>
<p>旋</p>
<p>转</p>
<p>x</p>
<p>度，绕</p>
<p>y</p>
<p>轴</p>
<p>旋</p>
<p>转</p>
<p>y</p>
<p>度</p>
<p>，</p>
<p>绕</p>
<p>z</p>
<p>轴旋转</p>
<p>z</p>
<p>度。因此，该值最为直观的形式是可以允许我们直接</p>
<p>以一个三维向量的形式来修改一个物体的角度，例如下面的脚本：</p>
<p>float mY &#x3D; 5.0;</p>
<p>void Update ()</p>
<p>{</p>
<p>mY +&#x3D; Input.GetAxis(“Horizontal”);</p>
<p>transform.eulerAngles &#x3D;new Vector3(0,mY, 0);</p>
<p>}</p>
<p>@宫古s驰月资料</p>
<p>如果你已经理解了上面的话，那么不出意外的，这段脚本会如你所愿的，按照鼠标在</p>
<p>水平方向上移动的方向绕</p>
<p>Y</p>
<p>轴旋转。通常情况下，我们不会单独设置欧拉角其中一个轴，</p>
<p>例如</p>
<p>eulerAngles.x &#x3D; 10</p>
<p>，因为这将导致偏移和不希望的旋转。当设置它们一个新的值时，</p>
<p>要同时设置全部。好在我们可以通过</p>
<p>Quaternion.Euler()</p>
<p>方法将一个</p>
<p>Vector3</p>
<p>类型的值转</p>
<p>化为一个四元数，进而通过修改</p>
<p>Transform.Rotation</p>
<p>来实现相同的目的。</p>
<p>3</p>
<p>、插值：</p>
<p>所谓插值是指在离散数据的基础上补插连续函数，使得这条连续曲线通过</p>
<p>全部给定的离散数据点。插值是离散函数逼近的重要方法，利用它可通过函数在有限个点</p>
<p>处的取值状况，估算出函数在其他点处的近似值。在某些情况下，如果我们希望过程中处</p>
<p>理得较为平滑，此时我们就可以使用插值的方法来实现对中间过程的模拟。在</p>
<p>Unity3D</p>
<p>中</p>
<p>我们可以使用两种插值方法，即线性插值</p>
<p>Lerp</p>
<p>，球形插值</p>
<p>SLerp</p>
<p>。我们来看下面的脚本：</p>
<p>void Rotating (float horizontal, float vertical)</p>
<p>{</p>
<p>&#x2F;&#x2F; Create a new vector of the horizontal and vertical inpu</p>
<p>ts.</p>
<p>Vector3 targetDirection &#x3D; new Vector3(horizontal, 0f, vert</p>
<p>ical);</p>
<p>&#x2F;&#x2F; Create a rotation based on this new vector assuming tha</p>
<p>t up is the global y axis.</p>
<p>Quaternion targetRotation &#x3D; Quaternion.LookRotation(target</p>
<p>Direction, Vector3.up);</p>
<p>&#x2F;&#x2F; Create a rotation that is an increment closer to the ta</p>
<p>rget rotation from the player’s rotation.</p>
<p>Quaternion newRotation &#x3D; Quaternion.Lerp(rigidbody.rotatio</p>
<p>n, targetRotation, turnSmoothing * Time.deltaTime);</p>
<p>&#x2F;&#x2F; Change the players rotation to this new rotation.</p>
<p>rigidbody.MoveRotation(newRotation);</p>
<p>}</p>
<p>插值的方法很简单，只要我们给出初始和结束的状态、时间就可以了，大家可以自己看</p>
<p>API</p>
<p>。</p>
<p>好了，有了这三部分的基础，我们就可以开始今天的内容了，今天的脚本分为两个部</p>
<p>分，第一部分是角色控制的部分，主要负责的角色在场景中的移动、转身和动画处理。第</p>
<p>二部分是相机控制的部分，主要涉及相机旋转、相机缩放的相关内容。下面，我们分别来</p>
<p>讲这两个部分，场景依然是博主自己在做的小游戏：</p>
<p>@宫古s驰月资料</p>
<p>如果你已经理解了上面的话，那么不出意外的，这段脚本会如你所愿的，按照鼠标在</p>
<p>水平方向上移动的方向绕</p>
<p>Y</p>
<p>轴旋转。通常情况下，我们不会单独设置欧拉角其中一个轴，</p>
<p>例如</p>
<p>eulerAngles.x &#x3D; 10</p>
<p>，因为这将导致偏移和不希望的旋转。当设置它们一个新的值时，</p>
<p>要同时设置全部。好在我们可以通过</p>
<p>Quaternion.Euler()</p>
<p>方法将一个</p>
<p>Vector3</p>
<p>类型的值转</p>
<p>化为一个四元数，进而通过修改</p>
<p>Transform.Rotation</p>
<p>来实现相同的目的。</p>
<p>3</p>
<p>、插值：</p>
<p>所谓插值是指在离散数据的基础上补插连续函数，使得这条连续曲线通过</p>
<p>全部给定的离散数据点。插值是离散函数逼近的重要方法，利用它可通过函数在有限个点</p>
<p>处的取值状况，估算出函数在其他点处的近似值。在某些情况下，如果我们希望过程中处</p>
<p>理得较为平滑，此时我们就可以使用插值的方法来实现对中间过程的模拟。在</p>
<p>Unity3D</p>
<p>中</p>
<p>我们可以使用两种插值方法，即线性插值</p>
<p>Lerp</p>
<p>，球形插值</p>
<p>SLerp</p>
<p>。我们来看下面的脚本：</p>
<p>void Rotating (float horizontal, float vertical)</p>
<p>{</p>
<p>&#x2F;&#x2F; Create a new vector of the horizontal and vertical inpu</p>
<p>ts.</p>
<p>Vector3 targetDirection &#x3D; new Vector3(horizontal, 0f, vert</p>
<p>ical);</p>
<p>&#x2F;&#x2F; Create a rotation based on this new vector assuming tha</p>
<p>t up is the global y axis.</p>
<p>Quaternion targetRotation &#x3D; Quaternion.LookRotation(target</p>
<p>Direction, Vector3.up);</p>
<p>&#x2F;&#x2F; Create a rotation that is an increment closer to the ta</p>
<p>rget rotation from the player’s rotation.</p>
<p>Quaternion newRotation &#x3D; Quaternion.Lerp(rigidbody.rotatio</p>
<p>n, targetRotation, turnSmoothing * Time.deltaTime);</p>
<p>&#x2F;&#x2F; Change the players rotation to this new rotation.</p>
<p>rigidbody.MoveRotation(newRotation);</p>
<p>}</p>
<p>插值的方法很简单，只要我们给出初始和结束的状态、时间就可以了，大家可以自己看</p>
<p>API</p>
<p>。</p>
<p>好了，有了这三部分的基础，我们就可以开始今天的内容了，今天的脚本分为两个部</p>
<p>分，第一部分是角色控制的部分，主要负责的角色在场景中的移动、转身和动画处理。第</p>
<p>二部分是相机控制的部分，主要涉及相机旋转、相机缩放的相关内容。下面，我们分别来</p>
<p>讲这两个部分，场景依然是博主自己在做的小游戏：</p>
<p>@宫古s驰月资料</p>
<p>如果你已经理解了上面的话，那么不出意外的，这段脚本会如你所愿的，按照鼠标在</p>
<p>水平方向上移动的方向绕</p>
<p>Y</p>
<p>轴旋转。通常情况下，我们不会单独设置欧拉角其中一个轴，</p>
<p>例如</p>
<p>eulerAngles.x &#x3D; 10</p>
<p>，因为这将导致偏移和不希望的旋转。当设置它们一个新的值时，</p>
<p>要同时设置全部。好在我们可以通过</p>
<p>Quaternion.Euler()</p>
<p>方法将一个</p>
<p>Vector3</p>
<p>类型的值转</p>
<p>化为一个四元数，进而通过修改</p>
<p>Transform.Rotation</p>
<p>来实现相同的目的。</p>
<p>3</p>
<p>、插值：</p>
<p>所谓插值是指在离散数据的基础上补插连续函数，使得这条连续曲线通过</p>
<p>全部给定的离散数据点。插值是离散函数逼近的重要方法，利用它可通过函数在有限个点</p>
<p>处的取值状况，估算出函数在其他点处的近似值。在某些情况下，如果我们希望过程中处</p>
<p>理得较为平滑，此时我们就可以使用插值的方法来实现对中间过程的模拟。在</p>
<p>Unity3D</p>
<p>中</p>
<p>我们可以使用两种插值方法，即线性插值</p>
<p>Lerp</p>
<p>，球形插值</p>
<p>SLerp</p>
<p>。我们来看下面的脚本：</p>
<p>void Rotating (float horizontal, float vertical)</p>
<p>{</p>
<p>&#x2F;&#x2F; Create a new vector of the horizontal and vertical inpu</p>
<p>ts.</p>
<p>Vector3 targetDirection &#x3D; new Vector3(horizontal, 0f, vert</p>
<p>ical);</p>
<p>&#x2F;&#x2F; Create a rotation based on this new vector assuming tha</p>
<p>t up is the global y axis.</p>
<p>Quaternion targetRotation &#x3D; Quaternion.LookRotation(target</p>
<p>Direction, Vector3.up);</p>
<p>&#x2F;&#x2F; Create a rotation that is an increment closer to the ta</p>
<p>rget rotation from the player’s rotation.</p>
<p>Quaternion newRotation &#x3D; Quaternion.Lerp(rigidbody.rotatio</p>
<p>n, targetRotation, turnSmoothing * Time.deltaTime);</p>
<p>&#x2F;&#x2F; Change the players rotation to this new rotation.</p>
<p>rigidbody.MoveRotation(newRotation);</p>
<p>}</p>
<p>插值的方法很简单，只要我们给出初始和结束的状态、时间就可以了，大家可以自己看</p>
<p>API</p>
<p>。</p>
<p>好了，有了这三部分的基础，我们就可以开始今天的内容了，今天的脚本分为两个部</p>
<p>分，第一部分是角色控制的部分，主要负责的角色在场景中的移动、转身和动画处理。第</p>
<p>二部分是相机控制的部分，主要涉及相机旋转、相机缩放的相关内容。下面，我们分别来</p>
<p>讲这两个部分，场景依然是博主自己在做的小游戏：</p>
<p>@宫古s驰月资料</p>
<p>如果你已经理解了上面的话，那么不出意外的，这段脚本会如你所愿的，按照鼠标在</p>
<p>水平方向上移动的方向绕</p>
<p>Y</p>
<p>轴旋转。通常情况下，我们不会单独设置欧拉角其中一个轴，</p>
<p>例如</p>
<p>eulerAngles.x &#x3D; 10</p>
<p>，因为这将导致偏移和不希望的旋转。当设置它们一个新的值时，</p>
<p>要同时设置全部。好在我们可以通过</p>
<p>Quaternion.Euler()</p>
<p>方法将一个</p>
<p>Vector3</p>
<p>类型的值转</p>
<p>化为一个四元数，进而通过修改</p>
<p>Transform.Rotation</p>
<p>来实现相同的目的。</p>
<p>3</p>
<p>、插值：</p>
<p>所谓插值是指在离散数据的基础上补插连续函数，使得这条连续曲线通过</p>
<p>全部给定的离散数据点。插值是离散函数逼近的重要方法，利用它可通过函数在有限个点</p>
<p>处的取值状况，估算出函数在其他点处的近似值。在某些情况下，如果我们希望过程中处</p>
<p>理得较为平滑，此时我们就可以使用插值的方法来实现对中间过程的模拟。在</p>
<p>Unity3D</p>
<p>中</p>
<p>我们可以使用两种插值方法，即线性插值</p>
<p>Lerp</p>
<p>，球形插值</p>
<p>SLerp</p>
<p>。我们来看下面的脚本：</p>
<p>void Rotating (float horizontal, float vertical)</p>
<p>{</p>
<p>&#x2F;&#x2F; Create a new vector of the horizontal and vertical inpu</p>
<p>ts.</p>
<p>Vector3 targetDirection &#x3D; new Vector3(horizontal, 0f, vert</p>
<p>ical);</p>
<p>&#x2F;&#x2F; Create a rotation based on this new vector assuming tha</p>
<p>t up is the global y axis.</p>
<p>Quaternion targetRotation &#x3D; Quaternion.LookRotation(target</p>
<p>Direction, Vector3.up);</p>
<p>&#x2F;&#x2F; Create a rotation that is an increment closer to the ta</p>
<p>rget rotation from the player’s rotation.</p>
<p>Quaternion newRotation &#x3D; Quaternion.Lerp(rigidbody.rotatio</p>
<p>n, targetRotation, turnSmoothing * Time.deltaTime);</p>
<p>&#x2F;&#x2F; Change the players rotation to this new rotation.</p>
<p>rigidbody.MoveRotation(newRotation);</p>
<p>}</p>
<p>插值的方法很简单，只要我们给出初始和结束的状态、时间就可以了，大家可以自己看</p>
<p>API</p>
<p>。</p>
<p>好了，有了这三部分的基础，我们就可以开始今天的内容了，今天的脚本分为两个部</p>
<p>分，第一部分是角色控制的部分，主要负责的角色在场景中的移动、转身和动画处理。第</p>
<p>二部分是相机控制的部分，主要涉及相机旋转、相机缩放的相关内容。下面，我们分别来</p>
<p>讲这两个部分，场景依然是博主自己在做的小游戏：</p>
<p>@宫古s驰月资料</p>
<p>本次的主角呢，是博主非常喜欢的角色谢沧行，好了，我们回到今天的内容里吧！在</p>
<p>第一部分，主要的是完成角色向各个方向的转身，这里博主定义四个方向</p>
<p>(</p>
<p>其实八个方向是</p>
<p>一样的！</p>
<p>)</p>
<p>，脚本如下：</p>
<p>using UnityEngine;</p>
<p>using System.Collections;</p>
<p>public class NoLockiVew_Player : MonoBehaviour {</p>
<p>&#x2F;*</p>
<p>自由视角下的角色控制</p>
<ul>
<li></li>
</ul>
<p>&#x2F;</p>
<p>&#x2F;*</p>
<p>作者：秦元培</p>
<p>*&#x2F;</p>
<p>&#x2F;&#x2F;</p>
<p>玩家的行走速度</p>
<p>@宫古s驰月资料</p>
<p>public float WalkSpeed&#x3D;1.5F;</p>
<p>&#x2F;&#x2F;</p>
<p>重力</p>
<p>public float Gravity&#x3D;20;</p>
<p>&#x2F;&#x2F;</p>
<p>角色控制器</p>
<p>private CharacterController mController;</p>
<p>&#x2F;&#x2F;</p>
<p>动画组件</p>
<p>private Animation mAnim;</p>
<p>&#x2F;&#x2F;</p>
<p>玩家方向，默认向前</p>
<p>private DirectionType mType&#x3D;DirectionType.Direction_Forward;</p>
<p>[HideInInspector]</p>
<p>&#x2F;&#x2F;</p>
<p>玩家状态，默认为</p>
<p>Idle</p>
<p>public PlayerState State&#x3D;PlayerState.Idle;</p>
<p>&#x2F;&#x2F;</p>
<p>定义玩家的状态枚举</p>
<p>public enum PlayerState</p>
<p>{</p>
<p>Idle,</p>
<p>Walk</p>
<p>}</p>
<p>&#x2F;&#x2F;</p>
<p>定义四个方向的枚举值，按照逆时针方向计算</p>
<p>protected enum DirectionType</p>
<p>{</p>
<p>Direction_Forward&#x3D;90,</p>
<p>Direction_Backward&#x3D;270,</p>
<p>Direction_Left&#x3D;180,</p>
<p>Direction_Right&#x3D;0</p>
<p>}</p>
<p>void Start ()</p>
<p>{</p>
<p>&#x2F;&#x2F;</p>
<p>获取角色控制器</p>
<p>mController&#x3D;GetComponent();</p>
<p>@宫古s驰月资料</p>
<p>&#x2F;&#x2F;</p>
<p>获取动画组件</p>
<p>mAnim&#x3D;GetComponentInChildren();</p>
<p>}</p>
<p>void Update ()</p>
<p>{</p>
<p>MoveManager();</p>
<p>&#x2F;&#x2F;MouseEvent();</p>
<p>}</p>
<p>&#x2F;&#x2F;</p>
<p>玩家移动控制</p>
<p>void MoveManager()</p>
<p>{</p>
<p>&#x2F;&#x2F;</p>
<p>移动方向</p>
<p>Vector3 mDir&#x3D;Vector3.zero;</p>
<p>if(mController.isGrounded)</p>
<p>{</p>
<p>&#x2F;&#x2F;</p>
<p>将角色旋转到对应的方向</p>
<p>if(Input.GetAxis(“Vertical”)&#x3D;&#x3D;1)</p>
<p>{</p>
<p>SetDirection(DirectionType.Direction_Forwa</p>
<p>rd);</p>
<p>mDir&#x3D;Vector3.forward * Time.deltaTime * Wa</p>
<p>lkSpeed;</p>
<p>mAnim.CrossFade(“Walk”,0.25F);</p>
<p>State&#x3D;PlayerState.Walk;</p>
<p>}</p>
<p>if(Input.GetAxis(“Vertical”)&#x3D;&#x3D;-1)</p>
<p>{</p>
<p>SetDirection(DirectionType.Direction_Backw</p>
<p>ard);</p>
<p>mDir&#x3D;Vector3.forward * Time.deltaTime * Wa</p>
<p>lkSpeed;</p>
<p>mAnim.CrossFade(“Walk”,0.25F);</p>
<p>State&#x3D;PlayerState.Walk;</p>
<p>}</p>
<p>@宫古s驰月资料</p>
<p>if(Input.GetAxis(“Horizontal”)&#x3D;&#x3D;-1)</p>
<p>{</p>
<p>SetDirection(DirectionType.Direction_Lef</p>
<p>t);</p>
<p>mDir&#x3D;Vector3.forward * Time.deltaTime * Wa</p>
<p>lkSpeed;</p>
<p>mAnim.CrossFade(“Walk”,0.25F);</p>
<p>State&#x3D;PlayerState.Walk;</p>
<p>}</p>
<p>if(Input.GetAxis(“Horizontal”)&#x3D;&#x3D;1)</p>
<p>{</p>
<p>SetDirection(DirectionType.Direction_Righ</p>
<p>t);</p>
<p>mDir&#x3D;Vector3.forward * Time.deltaTime * Wa</p>
<p>lkSpeed;</p>
<p>mAnim.CrossFade(“Walk”,0.25F);</p>
<p>State&#x3D;PlayerState.Walk;</p>
<p>}</p>
<p>&#x2F;&#x2F;</p>
<p>角色的</p>
<p>Idle</p>
<p>动画</p>
<p>if(Input.GetAxis(“Vertical”)&#x3D;&#x3D;0 &amp;&amp; Input.GetAxis(“</p>
<p>Horizontal”)&#x3D;&#x3D;0)</p>
<p>{</p>
<p>mAnim.CrossFade(“Idle”,0.25F);</p>
<p>State&#x3D;PlayerState.Idle;</p>
<p>}</p>
<p>}</p>
<p>&#x2F;&#x2F;</p>
<p>考虑重力因素</p>
<p>mDir&#x3D;transform.TransformDirection(mDir);</p>
<p>float y&#x3D;mDir.y-Gravity *Time.deltaTime;</p>
<p>mDir&#x3D;new Vector3(mDir.x,y,mDir.z);</p>
<p>mController.Move(mDir);</p>
<p>}</p>
<p>&#x2F;&#x2F;</p>
<p>设置角色的方向，有问题</p>
<p>void SetDirection(DirectionType mDir)</p>
<p>{</p>
<p>if(mType!&#x3D;mDir)</p>
<p>@宫古s驰月资料</p>
<p>{</p>
<p>transform.Rotate(Vector3.up*(mType-mDir));</p>
<p>mType&#x3D;mDir;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>这里定义四个方向，是按照逆时针方向转的，相邻的两个方向间相差</p>
<p>90</p>
<p>度，所以我们</p>
<p>只需要将当前的角度和目标角度相减就可以转到目标角度的方向</p>
<p>(</p>
<p>其实这是以前写的代码，</p>
<p>现在回头再看，直接用欧拉角似乎更为简单啊，呵呵</p>
<p>)</p>
<p>。这里主要的内容就是这样了。下面</p>
<p>我们来看相机控制部分的代码吧，这里的代码参考了</p>
<p>MouseOrbit</p>
<p>脚本，主要完成了鼠标</p>
<p>右键旋转控制，博主在此基础上增加了相机缩放的代码。提到相机缩放，其实就是根据鼠</p>
<p>标滚轮滚动的方向和大小重新计算角色与相机的距离，与之类似地还有小地图的放缩，其</p>
<p>实同样是通过修改距离来实现的。博主今天的一个体会是官方的代码能自己写一遍的最好</p>
<p>自己写一遍，这样好多东西就能在这个过程中给理解了。我们一起来看脚本</p>
<p>using UnityEngine;</p>
<p>using System.Collections;</p>
<p>public class NoLockView_Camera : MonoBehaviour</p>
<p>{</p>
<p>&#x2F;&#x2F;</p>
<p>观察目标</p>
<p>public Transform Target;</p>
<p>&#x2F;&#x2F;</p>
<p>观察距离</p>
<p>public float Distance &#x3D; 5F;</p>
<p>&#x2F;&#x2F;</p>
<p>旋转速度</p>
<p>private float SpeedX&#x3D;240;</p>
<p>private float SpeedY&#x3D;120;</p>
<p>&#x2F;&#x2F;</p>
<p>角度限制</p>
<p>private float MinLimitY &#x3D; 5;</p>
<p>private float MaxLimitY &#x3D; 180;</p>
<p>&#x2F;&#x2F;</p>
<p>旋转角度</p>
<p>private float mX &#x3D; 0.0F;</p>
<p>private float mY &#x3D; 0.0F;</p>
<p>&#x2F;&#x2F;</p>
<p>鼠标缩放距离最值</p>
<p>private float MaxDistance&#x3D;10;</p>
<p>private float MinDistance&#x3D;1.5F;</p>
<p>@宫古s驰月资料</p>
<p>&#x2F;&#x2F;</p>
<p>鼠标缩放速率</p>
<p>private float ZoomSpeed&#x3D;2F;</p>
<p>&#x2F;&#x2F;</p>
<p>是否启用差值</p>
<p>public bool isNeedDamping&#x3D;true;</p>
<p>&#x2F;&#x2F;</p>
<p>速度</p>
<p>public float Damping&#x3D;2.5F;</p>
<p>void Start ()</p>
<p>{</p>
<p>&#x2F;&#x2F;</p>
<p>初始化旋转角度</p>
<p>mX&#x3D;transform.eulerAngles.x;</p>
<p>mY&#x3D;transform.eulerAngles.y;</p>
<p>}</p>
<p>void LateUpdate ()</p>
<p>{</p>
<p>&#x2F;&#x2F;</p>
<p>鼠标右键旋转</p>
<p>if(Target!&#x3D;null &amp;&amp; Input.GetMouseButton(1))</p>
<p>{</p>
<p>&#x2F;&#x2F;</p>
<p>获取鼠标输入</p>
<p>mX +&#x3D; Input.GetAxis(“Mouse X”) * SpeedX * 0.02F;</p>
<p>mY -&#x3D; Input.GetAxis(“Mouse Y”) * SpeedY * 0.02F;</p>
<p>&#x2F;&#x2F;</p>
<p>范围限制</p>
<p>mY &#x3D; ClampAngle(mY,MinLimitY,MaxLimitY);</p>
<p>}</p>
<p>&#x2F;&#x2F;</p>
<p>鼠标滚轮缩放</p>
<p>Distance-&#x3D;Input.GetAxis(“Mouse ScrollWheel”) * ZoomSpeed;</p>
<p>Distance&#x3D;Mathf.Clamp(Distance,MinDistance,MaxDistance);</p>
<p>&#x2F;&#x2F;</p>
<p>重新计算位置和角度</p>
<p>Quaternion mRotation &#x3D; Quaternion.Euler(mY, mX, 0);</p>
<p>Vector3 mPosition &#x3D; mRotation * new Vector3(0.0F, 0.0F, -D</p>
<p>istance) + Target.position;</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/08/25/Unity%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/3.%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/M_3D.5%E7%82%B9%E5%87%BB%E7%A7%BBq%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/">← Next </a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/08/25/Unity%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/3.%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0/%E7%A7%BB%E5%8A%A82/"> Prev →</a></div></div></div></div><div id="bottom-btn"><a id="to-index" href="#toc-div" title="Catalog">≡</a><a id="to-top" onClick="scrolls.scrolltop();" title="to top" style="opacity: 0; display: none;">∧</a></div></article><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">WRXinYue</a></h1><div id="description"><p></p></div></div><div id="aside-block"></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script class="pjax-js">reset=_=>{code.findCode();mermaid.init(undefined, ('.mermaid'));}</script><script src="/js/arknights.js"></script><script>window.addEventListener("load",()=>{reset()})</script></body></html>