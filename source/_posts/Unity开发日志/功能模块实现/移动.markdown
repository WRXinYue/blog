---
title: 移动
date: 2022-08-25 03:26:16.0
updated: 2022-08-25 03:26:16.0
categories: 
- Unity
tags: 
- 功能模块实现
---

## 角色移动

~~~c#
public class Horizontal : MonoBehaviour
{
    private float m_speed = 5f;
}

void Start()
{
}

void Update()
{
    float h = Input.GetAxis("Horizontal");
    float v = Input.GetAxis("Vertical");
        
     //移动
     Vector mDir = new Vector3(h, 0 ,v);
     transform.Traanslate(mDir * Time.detaTime * m_speed);
}

~~~

## 根据相机方向控制角色移动

~~~c#
public class Horizontal : MonoBehaviour
{
    public Transform m_point;
    public Transform mesh; //角色模型
    private float m_speed = 5f;
}

void Start()
{
}

void Update()
{
    float h = Input.GetAxis("Horizontal");
    float v = Input.GetAxis("Vertical");
        
     //移动
     Vector mDir = new Vector3(h, 0 ,v);
     mDir = m_point.TransformDirection(mDir);//向面朝方向移动
     //if(!(h==0)&&(v==0))
     //mesh.rotation = Quaternion.LookRotation(mDir);
     transform.Traanslate(mDir * Time.detaTime * m_speed);
}
~~~

## 完整
~~~c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class HoshiHorizontal : MonoBehaviour
{
    public Transform m_point;
    public Transform m_FollowedCamera;

    private float m_speed = 5f; //移速
    private float m_rotate = 6f; //旋转速度
    private float m_rotateMultiplier = 1; //旋转倍率
    private Rigidbody m_rb;
    private Animator m_anim;
    private Vector3 m_Amount; //向量移动
    private CharacterController m_Ctrl; //玩家控制器

    void Start()
    {
        m_anim = GetComponent<Animator>();
        //m_rb = GetComponent<Rigidbody>();
        m_Ctrl = GetComponent<CharacterController>();
    }

     

    void Update()
    {

        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        Vector3 m_Dir = new Vector3(m_FollowedCamera.forward.x,0, m_FollowedCamera.forward.z).normalized;//目标方向的向量
         
        if (Input.GetMouseButtonUp(0))
        { 
            m_anim.SetTrigger("Attack");
        }
        else if(h!=0 || v != 0)
        {
            if (v > 0)
            {
                m_Dir = new Vector3(m_FollowedCamera.transform.forward.x, 0, m_FollowedCamera.transform.forward.z);
                Quaternion newRototion = Quaternion.LookRotation(m_Dir);
                transform.rotation = Quaternion.RotateTowards(transform.rotation, newRototion, 100);
            }
            if (v < 0)
            {
                m_Dir = new Vector3(-m_FollowedCamera.transform.transform.forward.x, 0, -m_FollowedCamera.transform.forward.z);
                Quaternion newRototion = Quaternion.LookRotation(m_Dir);
                transform.rotation = Quaternion.RotateTowards(transform.rotation, newRototion, 100);
            }
            if (h > 0)
            {
                m_Dir = new Vector3(m_FollowedCamera.transform.right.x, 0, m_FollowedCamera.transform.right.z);
                Quaternion newRototion = Quaternion.LookRotation(m_Dir);
                transform.rotation = Quaternion.RotateTowards(transform.rotation, newRototion, 100);
            }
            if (h < 0)
            {
                m_Dir = new Vector3(-m_FollowedCamera.transform.right.x, 0, -m_FollowedCamera.transform.right.z);
                Quaternion newRototion = Quaternion.LookRotation(m_Dir);
                transform.rotation = Quaternion.RotateTowards(transform.rotation, newRototion, 100);
            }
            m_anim.SetFloat("Speed",Mathf.Abs(h) + Mathf.Abs(v),0.01f,Time.deltaTime);
            m_Ctrl.SimpleMove(m_Dir * m_speed);
        }
        
    }
    private void FixedUpdate()
    {
        //m_rb.MovePosition(m_rb.position + m_Amount);
    }
}

~~~

## 斜向移动问题

现在您已经有了一个变量来存储角色的移动，接下来需要设置它的值。由于这可能会更改每一帧，因此需要在每一帧进行该设置 — 您应该在 Update 方法中进行该设置。

在 Update 方法中，创建 horizontal 和 vertical 变量后，添加以下行：

```
 m_Movement.Set(horizontal, 0f, vertical);
```

3D 空间中的矢量具有三个值 — 此 **Set** 方法为每一个分配一个值。该方法有三个参数，矢量的每个坐标对应一个参数。现在，移动矢量的值在 x 轴上为水平输入，在 y 轴上为 0，在 z 轴上为垂直输入。第二个参数的 0 后面还有一个 f，用于指示计算机将该数字视为浮点数。

现在您需要解决一个小问题。移动矢量由两个数字组成，这两个数字的最大值可以为 1。如果它们两者的值都为 1，则矢量的长度（称为其大小）将大于 1。这便是勾股定理描述的三角形的边之间的关系。

![img](https://connect-cdn-public-prd.unitychina.cn/h1/20190411/learn/images/e20f8154-d0c0-4368-a094-5ae59c4ba3aa_02.png)

选择要展开的图像

这意味着您的角色沿对角线移动的速度将比沿单个轴的移动速度更快。为了确保不会发生这种情况，您需要确保移动矢量始终具有相同的大小。为此，可对其进行**标准化**。对矢量进行标准化意味着保持矢量的方向相同，但是将其大小更改为 1。

在您先前写的代码行下面添加以下脚本，以便在矢量本身上调用方法：

```c#
 m_Movement.Normalize ();
```

您的完整脚本现在应如下所示：

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerMovement : MonoBehaviour
{
    Vector3 m_Movement;

    // 在第一次帧更新之前调用 Start
    void Start()
    {
        
    }

    // 每帧调用一次 Update
    void Update()
    {
        float horizontal = Input.GetAxis ("Horizontal");
        float vertical = Input.GetAxis ("Vertical");

        m_Movement.Set(horizontal, 0f, vertical);
        m_Movement.Normalize ();
    }
}
```

此示例包括获取输入与设置移动矢量之间的间隙。这并不重要，只是为了让脚本看起来更整洁。

~~~c#
void Update()
    {
        float horizontal = Input.GetAxis("Horizontal");
        float vertical = Input.GetAxis("Vertical");

        m_Movement.Set(horizontal, 0f, vertical);
        m_Movement.Normalize();

        bool hasHorizontalInput = !Mathf.Approximately(vertical, 0f);
        bool hasVerticalInput = !Mathf.Approximately(horizontal, 0f);
        bool isWalking = hasHorizontalInput || hasVerticalInput;
    }
~~~

