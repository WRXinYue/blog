第三个月主要学习了四大知识点:
面向对象基础
类库开发
设计模式
人工智能

//......................................................................................................................................................

在这四个内容中,我们写了三个大的系统,技能系统,AI的状态机,智能感知,自动行为操控,除了这几个比较重要的系统,我们还有几个不是很重要,但是却非常有效的系统,比如:

		动画系统:
动画系统由两个类组成,AnimationEventBehaviour,ChatacterAnimation,我们在整个项目中用到的动画都是由这两个类来完成的.
		
		角色系统:
角色系统是由3个类来组成的,CharacterStatus,MonsterStatus,PlayerStatus,但是角色系统中的信息并不是特别多,我们能写10个,就能写100个,也就是说一个人
物身上有1000个属性都没有问题,我们往里面塞就OK了,里面没有太多的逻辑,所以很容易搞定.

		运动部分(运动系统):
我们有一个类,CharacterMotor,角色马达类.

		输入控制系统:
CharacterInputController类.

		所以,我们在角色这个文件夹中,主要学习的是如何划分类,对于一个系统来讲,如何去划分它,不要说我从界面开始,就把所有的代码都写到一个脚本中,一定要分成不同
的脚本,因为这样去做,第一,可以复用,第二,我们将来修改的时候,很容易找到这个具体的类,也就是说,为了日后的维护,是非常方便的,所以在这里,我们分的就是用户的角色
系统,输入控制系统,运动系统,技能系统还有动画系统.

//.......................................................工具类 ..............................................................................
我们为了项目开发的便利,写了一些相应的工具.

1),ArrayHelper类

工具里边为了数组的处理,数组的排序,数组的找最大,找最小,做查找,就是反复使用的,所以我们重写了一个类叫ArrayHelper类,之所以写这个类的原因是,集合本身具有
Find,FindAll,Max,Min等的方法,而数组也具备一部分,数组也有Max,Mian,OrderBy等方法,而这些原生的方法在IOS上面是不能执行的,所以我们重写它的目的是为
了保证能在安卓,IOS,PC端都可以使用,那么这些功能我们主要重写的是什么呢?因为我们在原生的类中间有Linq,Linq的全称叫做语言集成查询,这样的技术在微软体系
中是非常有用的,Linq它有几个功能,Linq to Sql,我们甚至在Sql上不用写Sql语句,直接写Linq就可以查询,还有就是Linq To Object,专门针对从集合,数组做查询,还
有就是Linq To XML,专门针对XML文档的操作,这是Linq的三个主要技术,因为Linq里面用到很多的Lanbda表达式,还有需要一些动态编译,而这些动态编译有一部分
在IOS上是不支持的,因为IOS上对动态编译的控制是非常严格的,所以导致Linq的一些功能是IOS上是不能正常使用的,那么,之前我可能们提到过一点,在苹果商店里有一
个Linq to IOS,这个插件的目的是把Linq上常用的一些扩展方法做了重写,所以我们也就是做了重写,那我可不可以用这个插件?可以用,但是需要付费,虽然有这个插件,
里面的功能也有很多,但是我们不需要那么多的功能,我只需要我的项目中间所需要的东西,所以我们重写了它,这就是这个类的作用.这是一个非常有价值的类.

2):Debuger类

除了这个工具类,我们还做了一个工具类叫Debuger类,之所以要写Debuger类,今天大家已经体会到Debug带来的性能损耗了吧,我们100多个Debug同时输出,屏幕会
卡来卡去,所以对于Debug来讲,我们在调试的时候,是需要写调试信息的,但是在运行的过程中,我们是不需要它消耗性能的调试我要,但是我不想让他消耗性能,所以我们就希
望调试是可开可关的,好消息是Unity5.4版本可以实现,坏消息是5.4到现在还没有完全普及,那么在它没有普及之前我们该怎么办?我们就得自己来做,所以我们写了这样一
个Debuger类,目的只是为了包装原有的Debug,为什么要包装他?包装他的目的就是为了给它一个开关,我想需要它输出调试信息的时候打开,不想让它输出调试信息的时候
关闭,然后为了能够准确的定位到这个位置,所以我们最后把Debuger做了一个处理,把它写成一个类库,放入项目中的Plugins文件夹下,可以帮助我们在其他项目中也可以复
用,如果其他项目中也需要Debuger类,不需要类,不需要源码,只需要把这个dll文件加进来就可以

3),对象池

不管是在游戏,还是在虚拟现实也好,在项目开发过程中常用的一个功能就是对象池,对于对象池来讲,它也有开源的插件,叫PoolManager,我现在跟你讲的是在面试的过程中
你跟他怎么讲,你可能要跟他提到你的项目中间要用到了对象池,他可能会问你,你用的是哪一种?你可以告诉他,我是自己写的,为什么要自己写?PoolManager功能已经很好
了,为什么还要自己写?这是因为PoolManager对我来讲,不适合,因为它的功能太多了,我不想要这么多的功能,我只想满足我现有的项目需求就可以了,所以我们自己写了一个
按照我们的需求定制的对象池,但是写对象池的思路是一样的.
在对象池里面,为了管理不同类型的对象,我们做了个字典,而每一种类型的对象又可能有多个,所以我们采用的数据结构是字典套集合的方式,用字典来做键,用列表来做存储空间,
另外我们对对象池提出了一个很重要的功能,就是在释放的时候可以选择实时回收,也可以选择延时回收,并且为对象池也提供了清空的方案,如果从当前场景加载到下一个场景,我
要把整个场景中曾经加载过的对象清除掉,那我们Clear就可以了,那么通过Clear方法就可以把这个内存的资源释放掉,这是我们在对象池上面的一个优点,反复使用,那么会问到
对象池中的对象你如如何确定哪一些对象是可用的,哪一些是不可用的?也就是说怎么决定要不要去创建新的对象?其实,我们把用过的对象并没有销毁掉,而是做了隐藏,或者说是
取消激活,然后在每次使用的时候,查找哪些对象是处在非活动状态的,非活动状态的对象就意味着它在场景中没有出现,那我们就把它拿过来,拿过来以后可能会遇到一个问题,比如
有人会问你那你的小怪有没有做对象池?从我们项目本身来讲,我们的小怪并没有做对象池,那么,如果小怪让你做对象池,你会怎么做呢?那我们去调用对象池中的CreateObject
方法就可以了吧,好,调它是可以,但是会有一个问题,如果小怪被打死,你是不是把它缓存了,缓存了之后,小怪身上的血是没有的,因为他被打死了,小怪身上的状态已经发生变化,那么
这种情况怎么处理?我们把对象创建出来之后,可以写个脚本来做还原,所谓的还原就是初始化,初始化的过程就相当于是拍张快照,一出来长什么样,我就拍张快照记录下来,然后在
小怪重新加载回来的时候,我用曾经拍的那张快照还原回来就可以了.那么从技术上怎么解决?如果从技术上解决的话,第一:可以通过对象序列化来解决,我可以把这些数据序列化到
内存中,或者序列化到文件里都可以,因为序列化可以选择不同流,我选择文件流,那么我就序列化硬盘上,如果我选择内存流,那么我就序列化到内存里,所以可以通过序列化来做,这是
一种用过技术上的解决手段,第二:我们可以通过设计上的手段解决,设计上的解决手段怎么做呢?我们可以通过设计模式上的备忘录,也就是说当还原数据的时候,我们可以通过在一个
对象的状态出来之前,我们把它记录下来,当还原的时候,我用记录下来的状态把它还原,也就是说你原来的技能是什么样的,血是什么样的,通通还原回来,那么就可以保证我们的对象
可以反复复用,好,这是我们的第三个工具,对象池.

4):MonoSignleton类

第四个我们写的工具类MonoSingleton,为什么我们需要它,因为我们在整个案例中间多次用到了单例模式,所以如果我们每次写那么多的重复代码,那么这是一种浪费,所以
我们做了一个抽象的父类,就是一个单例的父类,在这个单例类中,大家需要记住它的做法,而不是记住代码,对于这个单例来讲,我们是怎么做的?对于一个脚本来讲,我们可
以手动挂到物体上,也可能会自动挂到物体上,所以我们在做这个单例之前,就是先要考虑一下,因为Unity中对象的创建有很多种,我们可以选择new的方式创建对象,也可以
用添加组件的方式来创建对象或者是手动挂脚本的方式来创建,所以对于一个脚本来讲,在Unity中创建对象的方式有很多种,我们要考虑到它的这几种方案,那么在取得对象
之前,我们先去查找一下,看看场景中是否出现了,那么这种出现的可能性,一方面是它手动挂上去的,一方面是通过Add添加上去的,所以我们先去找,如果找到了,我们就不再
手动创建了,如果说没找到,那么我们再手动创建.在手动创建的时,我们会遇到个问题,这个脚本对象继承自MonoBehaviour,一般我们是不建议去new的,那么怎么办?就挂物
体,所以我们就new一个空物体,然后把这个脚本通过代码添加脚本的方式挂上去,挂上去以后,再去得到这个组件,这样的话们不管以后什么时候用,那我都是先到场景中去
找,就是你挂过了,我就不在去挂了,也就是不再去创建了,这是我们做了这样一个父类,一个泛型的父类,适用于所有的类型,如果将来有类需要做单例的话,
继承MonoSingleton就可以.

5):ResourcesManager类

第五个是一个资源管理工具,因为资源会随着项目不断开发的进度往后走,那么资源会越来越多,有一些资源我们可能会做成AssetsBundle,将来打包去下载,或者有一部分
资源就放到Resources文件夹下,当放到Resources文件夹下,目录就会变得很复杂,因为资源很多,所以我们要分门别类来存放,那么路径就是一个问题,如果每次有用原生的
Resources.Load()方法加载,会带来一个问题,就是我必须要记住它的路径,而且这个路径不能改变,一旦改变我的代码就麻烦了,所以为了解决这个问题,我们做了一个Unity
的工具,在菜单上面做了一个生成资源配置文件,也就是读表,也就是俗称的配表,我们把整个的资源做了一个表,当然这个表不是表格,也不是数据表,而是一个txt的文件,那
么这个文件里面,我们配的是键值对的结构,用资源的名称充当键,用资源的全路径充当值,在编辑的过程中,我们就可以生成这样的一个配置文件,生成配置文件之后,我们又
包装了Resources.Load,然后写了一个自己的资源管理类,如果在项目中用到资源需要加载的话,那我们就去调这个ResouecesManager来加载资源,在这个类里面,我们读取配
置文件,通过客户端所提供的资源的名称,我们把这个名称转化成所需要的具体路径,然后加载,再返回给调用者,所以整个工程中只要用到Resources中的资源,都统一走一个
入口就是ResourcesManager,这样我们对资源就有了控制和管理,所以称之为资源管理类

6):TransformHelper类

最后一个我们做了一个TransformHelper类,因为在物体身上的层次结构是比较深的,那我想找到某一个物体的话,第一个方案,我可以调本身的Find()方法,Find方法会在整个
场景中查找,这样的话,性能会比较差,另外,我们还可以通过调FindChild,但是该方法只适合找他的子级,如果找第三层级的话就找不到,为了解决这个问题,我们重写了
FindChild方法.另外在项目中,可能会多次用到旋转,所以我们就把转向也进行了包装,写成了一个工具,虽然他的代码并不多但是每次都写也是重复,所以我们就提取了一个
方法出来,写一个LookAtTarget方法,如果将来还有与Transform有关的更多的功能,那么我们都可以放到TransformHelper类当中.


//..........................................技能系统(技能数据类,技能管理类,技能释放器类) .......................................................

那么这几个工具类说完之后,我们就进入到具体的系统开发,首先将的是技能,说到技能,我们就不得不谈技能的设计思路,技能系统因为我们要考虑到系统中间它的技能是非常
丰富的,以天龙八部的技能表为蓝本来设计了自己的技能,对于技能,我们发现有很多的共性数据,当然也有很多不同的东西,共性的东西就是所有的技能都有攻击范围,攻击的群
体,持续的时间,伤害的间隔等等,数据是共性的,那么不同的就是说技能的选区是不同的,有的技能攻击范围是圆形的,有的技能攻击范围是扇形的,有的技能只对敌人造成伤害,
有的技能在对敌人造成伤害的同时还会有一些特殊的影响,比如:眩晕,属性值的变化,防御降低,包括减免,嘲讽,那么这都属于一些特殊效果,所以考虑到这些特殊结构之后,我
们发现:如果我把每个技能都写成一个单独的类,这是一个最简单的办法,但是这会带来一个麻烦,如果它有30个技能,我就得写30个类,另外还有一个问题就是如果用户改变了技
能,我可能就要改这个类,这就很麻烦,而且这张技能表也不能统一的进行配置,所以我们并没有采用这种办法,而我们采用的办法是:写一套逻辑,来管理所有的技能.那么这就出
现了技能设计的架构,我们把技能中用到的所有的数据做成一个技能数据类,对于每一个角色所拥有的技能我们做一个技能管理类,也就是说角色身上携带哪些技能,我们就做一
个技能管理,那么,最终技能的释放我们写了一个很重要的释放器,这是我们整个技能系统中最核心.最难的一块,那么释放器里面要做的事情有很多,因为每个技能的选区不同,
所以释放器要初始化你的选区,每个技能对自身,对目标都会有一些相应的影响,所以我们要做影响方面的算法,为了能够让技能复用这个释放器,释放器可能会有近身释放,有远
程释放,有隔空释放,有延时释放,所以我们也会把释放器做成很多的派生,做成不同的释放器.这就产生了另一块,释放器的架构,对于释放器来讲,它主要关心的几个内容就是:
一:我们怎么选择敌人,二:怎么影响自己和影响目标,对于选区来讲,它有多种选择算法,所以对于一个释放器来讲,它可能最终选择一个,一个技能会相应的配合一个释放器,释
放器是可以共用的,也就是说我一个释放器技能适用于多个对象,那么在释放的过程中,我们就需要给它配置算法,因为算法在改变,所以我们选择了策略模式,把这个算法进行提
取,把每一种算法都做成相应的策略,然后给释放器做相应的配置.另一个对目标影响和对自身影响,是采用同样的策略模式进行的抽象,然后把它每种影响的算法都进行了提取,
提取之后对于一个释放器来讲,我们的选择算法可能只是影响到一种,只有一种来配置,但是目标影响算法可能需要多个来叠加,就是刚刚所说的可能会对敌人造成伤害,也可能
对敌人造成眩晕,这样的话就有多个效果产生,那么多个效果产生怎么办?我们做了一个集合,在释放器里面做了目标影响集合和自身影响集合,而释放器本身也是有变化的,根据
释放器选择近身释放和远程释放,它的释放流程是不同的,所以我们把释放器也进行了派生,派生出近身,远程和隔空,最后整个释放器这块我们选择的是一个桥接的模式,桥的设
计模式来解决两端的不同变化,这样写的好处是什么呢?好处就是如果策划跟我们讲,我们的选择算法有增加,多了一种新的算法,那么没关系,我加个派生类就可以了,如果策划
跟我讲,又多了一种新的特殊效果,那么没关系,我加入一个新的对目标影响和对自身影响的派生类就可以了,这样对于策划需求的改动,我不需要做大量的调整,只需要增加新的
派生类就可以解决,这样就体现了我们在编程中间所要追求的目标,开闭原则,这就是我们技能系统的设计方案.

在技能上面,我们为了技能的使用方便,为技能写了一个技能的外观,就是在Character里面我们会看到一个CharacterSkillSystem,因为技能系统是比较复杂的,考虑到技能系统
使用的位置是比较多的,一方面技能系统的使用来自于主角的控制,就是输入控制的部分,另一方面它的使用可能来自于AI,而且技能系统我们是可以复用的,主角和小怪都能用,
任何一个角色进来都可以使用技能系统,所以我们为了能够让它使用起来更方便,而且并不希望客户端知道我们底层技能管理是怎么回事,技能释放是怎么回事,所以我们在这里
采用了一个外观类,把整个技能系统进行了封装,封装之后提供了一个非常简单的接口,就是使用技能,在技能系统里面我们提供了一个叫做AttackUseSkill,所以对于客户端来
讲,它只需要知道我需要使用哪个技能,是否是连击就可以了,这样就方便了整个技能的使用,同时我们再来说一下,技能是有连击的,那么连击是怎么做的?因为我们当时考虑到
连击需要控制,A可能会连击B,B可能会连击C,这是一种固定连法,如果我在技能上面直接配好ABC,这样的连击就比较死板,我希望连击是可以让用户进行配置的,所以我们做了一
个像链条式的我们数据结构中的链表结构,前面勾着后面的,后面的再勾着最后,A勾着B,B在勾着C,C在勾着D,通过这样的一个挂钩之后,我们不用去控制着他的整个技能链,我们
只需要知道A后面是谁就可以了,在做连击的时候,只需要知道当前技能的下一个技能是什么就可以,这样在技能的搭配上面,在技能的连击上面,也是非常容易去控制的

之后再来说一下我们的输入控制上面是怎样去做的连击,因为在连击过程中,用户会持续按住按钮,我们选择使用EasyTacth来做的输入控制,在连击过程中,在1S中之内可能会触
发多次,我们在连击上面做了一个处理,能连击的动画节奏都差不多,之间相差并不大,所以我们在当时取了一个时间值就是1s,动画控制在1S之内,如果在1S之内用户连续按下两
次键,我们只播放一次技能动画,在1S之后才会处理第二次,这样即使用户按的再快,连击的节奏是不变的,这就是关于连击的控制.

//..........................................AI系统 ....................................................................................

技能做完之后,我们开始制作AI系统,AI系统我们这里采用了比较常用的有限状态机的设计思路,有限状态机我们当时考虑到这样的一个因素,并没有采用if..else 结构,因为
if...else的结构是非常死板的,它不能够去做改变,所以我们当时在状态机上面考虑到几个问题,首先是先分析了状态转换,先生成了一个状态转换表在状体转换表上面我们罗
列了在某种技能的情况下,遇到什么样的条件,可能会做出什么样的输出,在这个问题上面,我们发现:我的状态可能是有增加的,另外输入条件也是可能有增加的,所以我们发现
在这个状态机上面的两个变化点,一个变化点就是状态的数量是可以变化的,第二个变化点就是输入条件是可以变化的,同时在这两个结合上也会有变化,因为即使是在同样的一
个条件,在不同的状态下,会产生不同的结果,所以我们并没有做全局上的条件切换处理,而是把切换包装给每一个状态,在状态里面我们做了一张映射表,为了满足状态可以增加,
条件可以增加,我们把条件和状态做了提取,采用了典型的状态模式,也就是它操作什么样的行为,取决于它的状态,状态把每一个行为单独提出来,把每一个条件也单独提出来,
为什么要把条件提出来,因为我想让状态和条件自由组合,当条件和状态自由组合之后,就可以产生出很多种不同的效果,最初我们设计这个状态机的时候,提出了三个目标,一是
想让状态机可以用现有的条件,现有的状态自由组合出不用的AI,二是希望它能够应对状态和条件的增加,三是我们希望它是可配置的,我们为了得到这三个灵活点,首先怎么样
能够用同样的状态,同样的条件不同组合之后,产生2套AI,首先要打散,所有的状态和所有的条件都要打散,打散之后就要像积木一样自由组合,怎么组合?为了能够做调整,我们
制作了配置文件,整个AI是通过配置文件来配的,配置文件配好之后自动形成一套AI,所以在状态机上面我们提供了这样一套架构,在这个架构里面,状态提取出来,条件提取出来,
那么状态和条件之间的切换由谁来控制?由状态机控制.然后还有另一个问题就是不同的状态用到的资源是不一样的,有的状态可能要用到技能,有的状态可能要用到动画,有的
状态可能要用到角色系统,甚至用到装备系统等等,这样的话,如果让状态类自己获取这些资源,那么整个AI这一块是比较乱的,耦合度是比较高的,所以我们最终选择一个中间
的方式,把所有的资源获取都交给状态机,由状态机统一向外部获取资源,所以在状态机里面它保存了关于状态和条件所需要的必要数据,整个状态之间运动的控制部分我们选择
寻路的方案来做的,所以在状态机里面还要用到寻路,要用到技能,要用到动画,要用到角色控制等等,在状态里面,我们把状态机的功能划分了一下,划分为关于状态部分的管理
关于状态机配置加载的管理,还有为其他的状态条件类提供的行为和数据,还有它自身的一些数据,那么在每一个状态类里面我们考虑状态的每一个阶段,状态的初始化阶段,状
态进入的时候要执行的工作和持续执行的行为和它退出状态之后执行的行为,所以做了这样一个处理,那么在这个系统上面,如果说面试官听懂了,它可能会问你这样一个问题,
你的条件是单层次的,如果我做成多层次怎么办?比如巡逻的时候,发现了目标,他并不会马上逃跑,因为他在发现目标的时候会进行二次的判断,如果自身的生命值高于目标,就
去攻击,如果低于目标就选择逃跑,它从发现目标开始就产生第二层次的条件了,这个问题怎么解决?可以通过组合模式中的树模式,你可以先这样讲,如果层次比较深的话,我们
用状态机做起来会比较麻烦,我可以选择使用行为树,就目前的案例来讲,我的解决方案是我可以在Trigger上面加层次,我目前的Trigger上面只是一个单层次,我可以在Trigger
类里面做一个层次出来,比如说:我们可以做一个子条件的集合,这样就实现了层层嵌套,当层层嵌套的时候,我的每一个子条件都会有一个索引,都会有一个TriggetID,那么我怎
么在上面体现2个TriggerID?比如:发现目标---自身生命高于目标,2个Trigger,这里,我们是2个枚举,如何让两个枚举形成并列关系?可以通过标识类枚举,枚举的标识的意思就
是你把枚举的每个值设置成2的N次方,这样让2个枚举做按位或运算,得到结果是不会有重复的,通过这样的枚举做运算就可以了,或者我们直接在配置文件里面直接用字符串配
2种方案,在配置文件里配置完成后,解析一下配置文件就会得到2个条件,后面的作为前面的层次,所以我们在配置文件上做一个格式的调整,来应对这样的层次变化,所以很容易
改,这是关于状态机部分的条件做层次化,两个方案,如果层次太复杂,可以使用行为树,如果没有那么复杂,没有必要使用行为树,就在上面做层次就可以了,这是我们状态机部分
的核心.


//..........................................智能感知系统 ....................................................................................

我们又写了一套系统叫感知系统,智能感知系统主要是解决了2个感知能力,一个是视觉感知,一个是听觉感知,这套系统之所以要单独来做是因为想让我们的应用是非常方便的
如果在场景中间有一个物体想被发现,我们就给它加Trigger,如果有一个物体向具有感知能力,就加Sensor,这样就不需要为不同的物体写不同的脚本,需要做强引用,A不需要知
道我要感应B,还是要感应C,都不做关联,那么我们在这里采用的模式是中介者模式,因为一感应器它可能要感应多个,但是同时一个感应器要感应多个触发器,但反过来来讲,一
个触发器也可能会同时被多个感应器所感应,所以这个流程上面很明显这是一个多对多的交互过程,如果是一对多的交互过程,我们会选择使用观察者模式,就像我们的动画事件
里边,我们选择的是观察者模式,因为这是一对多的交互,而在这里的感应操作是多对多的感应交互,所以我们选择了中介者模式,选择中介者模式的话,就把两端所交互的对象分
开,我们分出来感应器和触发器,在中间做了一个感应系统,感应系统来负责之间的交叉过程,这样做了之后,好处就是如果你有新的感应器,只要写新的派生类就可以了,把具体
算法写到派生类里边,触发器也是一样,感应系统是一个单例的,在一个场景中间,我只需要一个感应系统,这样做还有一个好处就是感应器可以随时开,随时关,触发器也可以随
时开,随时关,这样的话,对于一个物体,如果他是若隐若现,或者说有时候有声音,有时候没有声音,我门很容易就可以控制了,我只要控制这个脚本的禁用和启用就可以控制到
它是否被感应到,这样做都是为了使用上的灵活

//..........................................自动行为操控系统 ....................................................................................

还有一个系统就是我们这两天所做的自动行为操控系统,自动行为操控系统我们在当时设计的时候要考虑到,操控系统还有它的多种操控,但是不同的操控分析之后它只是
在行动轨迹方面的不同而已,但是在具体的运动流程上是一样的,我需要的运动数据也是一样的,所以我们就又做了一个过程,封装变化,把所有不同的算法提取出来一个父类来,
于是我们就提了一个操控类,操控类来封装了具体的算法,到了运动部分,我们做了一个运动体,运动体会考虑到运动的控制可能会不一样,所以把运动控制和运动体分开了,分开
以后,但是运动控制中间我需要用到运动体,在这个流程上面我们选择了继承的方案,继承方案的话,如果将来出现新的运动方式的话,我只需要在实现一个新的运动控制类就可
以了,那么对于运动体来讲,所包装的都是一些基础的数据,如果说我们的运动控制不会有第二种,那么就可以把运动控制和运动体整合,整合以后就变成一个典型的策略模式,
虽然现在其实看上去像桥模式,但是实际上还是策略模式,因为我们的重点是在算法的切换上和算法的组合上,这里虽然用的是策略模式,但是我们是对策略进行了改造,因为在
这里的操控我们是可以叠加的,可以有多个操控同时组合在一起,所以我们在运动体这边做了一个操控对象的列表.操控方面的话我们提供了这样几个操控,具体的比如像靠近,
远离,拦截,逃避,到达,巡逻和徘徊,群体操控上面我们做的聚集和分散,可能有人会问你,什么叫群体操控?群体操控的话我们控制的就不是一个对象,控制的是多个对象,那么
多个对象如何知道控制哪一些?我们这里做了一个自我邻居识别,选择使用的是雷达,那么雷达是怎么做的?我们可以有2个方案来解决,我可以选择目标然后做筛选,也可以选择
使用球型覆盖射线,虽然球型覆盖射线相对比较简单,但是我们会考虑到性能,所以我会选择使用查找的方案,为什么说查找的方案比较快呢?因为该方案只在内存中查找对象的
引用,它不会去找游戏物体,引用都在栈上,所以很快,那么射线为什么会慢?因为射线里面有大量的碰撞算法,在引擎里面肯定要去做碰撞检测,一个覆盖射线的话,它是一个球面,
这样的一个球面,它里面检测的范围比较大,消耗的时间比较多,如果具体去测试的话,同样的数量下,用查找和使用球型覆盖射线查找性能消耗应该在30倍左右,所以我们选择了
查找方案,这就是我们整个系统的架构.






