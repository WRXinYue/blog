---
updated: 2023-04-18 15:13:18
---

---
title: 执行流程
categories:
 - WebFrontend
tags:
 - ''
data: 2023-04-18 15:12:47
updated: ''
---
# Web前端历史

## Web1.0时代

在web1.0时代，没有前后端之分。页面由 JSP、PHP 等工程师在服务端生成，浏览器负责展现。基本上是服务端给什么浏览器就展现什么，展现的控制在 Web Server 层。

![image-20230219204441797](https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/image-20230219204441797.png)

这种架构的好处就是简单快捷。但是，缺点也非常明显：JSP代码难以维护

为了让开发更加便捷，代码更易维护，前后端职责更清晰。便衍生出MVC开发模式和框架，前端展示以模板的形式出现。典型的框架就是Spring，Suructs、Hibernate。整体框架如图所示：

![img](https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/2062729-b718cd0a7d3b32b9.png)

使用这种分层架构，职责清晰，代码易于维护。但这里的MVC仅限于后端，前后端形成了一定的分离，前端只完成了后端开发的view层

## Web2.0时代

自从Gmail的出现，ajax技术开始风靡全球。有了ajax之后，前后端的职责就更加清晰了。因为前端可以通过Ajax与后端进行数据交互，因此，整体的架构图也变化成了下面这幅图：

![web2.0](https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/web2.0.jpg)

Ajax 技术与后台服务器进行数据交换，可以使得前端开发人员只需要专注于页面内容的开发，数据可以由后台提供，从而分工更加明确，提高了开发效率。而且，使用 Ajax 技术可以实现页面的部分刷新，减少了服务器端负载和流量消耗，用户体验更佳。



# 前后端分离后的架构演变-MVC、MVP和MVVM

## MVC

前端的MVC与后端类似，具备View、Controller和Model。

Model：负责保存应用数据，与后端数据进行同步

Controller：负责业务逻辑，根据用户行为对Model数据进行修改

View：负责视图展示，将model中的数据可视化出来

三者形成了一个如图所示的模型：

![4b233d989851c553aede751f7cdf4885](https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/4b233d989851c553aede751f7cdf4885.jpg)

这样的模型，在理论上是可行的。但往往在实际开发中，并不会这样操作。因为开发过程并不灵活。例如，一个小小的事件操作，都必须经历这样的一个流程，那么开发就不再便捷了。

在实际场景中，我们往往会看到另一种模式，如图：

![0f92b4266a](https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/0f92b4266a.jpg)

这种模式在开发中更加灵活，backbone.js框架就是这种的模式。

但是，这种灵活可能导致严重的问题：

1.数据流混乱：

![66066801154](https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/66066801154.jpg)

2.View比庞大，而Controller比较单薄：由于很多开发者就会在view中写一些逻辑代码，逐渐的就导致了view中的内容越来越庞大，而controller变得越来越单薄。

## MVP

MVP模式虽然在前端开发并不常见，但是在安卓等原生开发中，开发者还是考虑到它

MVP模式与MVC唯一不同的在于Presenter和Controller

再MVC模式中我们使用观察者模式，来实现当Model层数据发生变化的时候，通知View层的更新，

这样View和Model层耦合在一起，当项目逻辑变得复杂的时候，会造成代码的混乱

MVP的模式通过使用Presenter来实现对View层和Model层的解耦。

MVC中的Controller只知道Model的接口，因此它没有办法控制View层的更新，MVP模式中View层的接口暴露给了Presenter，因此我们可以在Presenter中将Model的变化和View的变化绑定在一起，以此来实现View和Model的同步更新，这就实现了对View和Model的解耦，Presenter还包含了其他的响应逻辑。

MVP与MVC很接近，P指的是Presenter，presenter可以理解为一个中间人，它负责着View和Model之间的数据流动，防止View和Model之间直接交流。我们可以看一下图示：

![6364fee4b2](https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/6364fee4b2.jpg)

我们可以通过看到，presenter负责和Model进行双向交互，还和View进行双向交互。这种交互方式，相对于MVC来说少了一些灵活，view变成了被动视图，并且本身变得很小。虽然它分离了View和Model。但是应用逐渐变大之后，缺陷也会随之暴露。

缺陷：

由于大部分逻辑都需要presenter去进行管理，从而导致presenter的体积增大，难以维护。如果需要去解决这个问题，或许可以从MVVM的思想中找到答案。

## MVVM

首先，何为MVVM呢？MVVM可以分解成(Model-View-VIewModel)。ViewModel可以理解为在presenter基础上的进阶版。废话不多说，先上图例：

![fe2ae148d68](https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/fe2ae148d68.jpg)

![KZFfe.png](https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/alcyu8psepmvwkrbiyy8.png)

在这里View是ViewModel的外在显示，和ViewModel的数据是同步的。一旦View中的数据发生变化，会自动同步到ViewModel，然后ViewModel可以将变化的数据传给Model；反过来也是一样的，Model中的数据一旦发生改变，就会将值传给ViewModel，而ViewModel也会同步更新到view中。现在的框架实现这样的形式，各有各的不同。主要的三个框架angular2、vue、react都是实现了这样子的模式。

这种的好处就是View和Model之间被分离开来。view不知道model的存在，viewmodel和model也觉察不到view。事实上，model也完全忽略viewmodel和view的存在。这是一个非常松散耦合的设计。

但它也不是所用地方都适用的，例如，后端开发是适用的。因为网络资源成本过高，开发成本过高导致的。

![image-20230219215903465](https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/image-20230219215903465.png)

MVVM模式中的VM，指的是ViewModel，它和MVP的思想其实是相同的，不过它通过双向的数据绑定，将View和Model的同步更新给自动化了。当Model发生变化的时候，ViewModel就会自动更新，这样就将Presenter中的工作给自动化了

## MVVM执行流程

MVVM 是一种基于前端的架构模式，它的执行流程如下：

1. 视图层 (View)：MVVM 模式的视图层通常由 HTML 和 CSS 组成，它负责用户界面的呈现和交互。在 Vue.js 中，视图层使用模板语法来描述 UI。
2. 模型层 (Model)：模型层是应用程序的数据模型，它负责处理数据的读写操作。在 Vue.js 中，模型层由 Vue 实例的数据属性组成。
3. 视图模型层 (ViewModel)：视图模型层是连接视图层和模型层的桥梁，它负责将模型层中的数据和方法绑定到视图层上。在 Vue.js 中，视图模型层由 Vue 实例的计算属性、方法和指令组成。
4. 数据绑定：MVVM 模式使用双向数据绑定机制，实现视图层和模型层之间的数据同步。当模型层数据发生变化时，视图层会自动更新，反之亦然。
5. 事件监听：视图层通常会触发各种事件，例如点击按钮、输入文本等。在 Vue.js 中，可以使用指令和事件监听器来处理这些事件，例如 v-on:click。
6. 视图更新：当模型层数据发生变化或用户事件触发时，视图模型层会自动更新视图层，反映最新的数据状态。

总的来说，MVVM 模式的执行流程是：视图层通过指令和事件监听器与视图模型层进行交互，视图模型层通过计算属性、方法和指令将模型层的数据和方法绑定到视图层上，实现视图层和模型层之间的双向数据绑定和自动更新。这种模式能够提高应用程序的可维护性和可测试性，同时也可以减少开发人员的工作量，提高开发效率。



# 后端架构

## B/S架构、C/S架构

SSM框架（Spring + SpringMVC + MyBatis）中的Spring MVC是基于MVC设计模式的实现。因此，SSM框架可以看作是一种基于MVC设计模式的WEB应用程序开发的框架

## 三层架构

三层架构(3-tier architecture)基于**"高内聚低耦合"**设计思想。三层架构我们都听说过，要想知道SSN工作流程就必须知道三层架构，下面我来给它们一步一步分块解析。

关于三层架构我不得不吐槽它们的大名：

* **表示层(UI、Presentation layer)**、视图层(View layer)、表现层、用户界面层、前端层、Web层等
* **业务逻辑层(BLL、Business Logic layer)**、应用层(Application)、服务层(Service layer)等
* **数据访问层(DAL、Data Access layer)**、数据持久层(Persistence layer)、DAO层(Data Access Object layer)等

![image-20230218200927398](https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/image-20230218200927398.png)

现在，它们的名字和之间的关系我们大概理解了。三层架构有表示层

关于上述三个主要层次，还有一些相关的层次和模块：

1. 应用服务层（Application Service layer）：用于提供面向应用的服务接口。
2. 业务服务层（Business Service layer）：用于提供面向业务的服务接口。
3. 领域层（Domain layer）：用于定义业务领域对象和业务规则。
4. 数据库访问层（Database Access layer）：用于实现与数据库的交互。
5. 数据访问对象层（Data Access Object layer）：用于封装数据访问操作。
6. 模型层（Model layer）：实体类层、用于表示业务对象和业务规则。

## MVC架构工作流程

![image-20230218124957747](https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/image-20230218124957747.png)

1. 用户发起 request 请求，请求被控制器（Controller）接收，并将用户请求的数据委托给模型（Model）进行处理。
2. 控制器通过模型处理数据，并得到处理结果。模型通常指业务逻辑。
3. 模型处理结果返回给控制器。
4. 控制器将模型数据传递给视图（View），视图通过控制器进行数据展示。在 Web 中，模型无法将数据直接在视图上显示，需要通过视图和控制器完成。如果在 C/S 应用中，模型可以将数据在视图中展示。
5. 控制器将视图响应（response）给用户，通过视图展示给用户所需的数据或处理结果。

View和Mode应用了观察者模式，当Model层发生改变的时候。它会通知有关View层更新页面

controller层是View层和Model层的纽带，主要负责用户与应用的响应操作，它主要负责用户与应用程序的响应操作，当用户与页面发生交互的时候，Controller中的事件触发器就开始工作了，通过调用Model层，来完成对Model的修改，然后Model层再去通知View层更新。

![image-20230219215358671](https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/image-20230219215358671.png)

**总结：**

MVC（Model-View-Controller）是一种常见的软件架构模式，它把应用程序分为三个核心组件：模型、视图和控制器，用于更好地组织代码、降低耦合度、提高可维护性。

MVC 的工作流程如下：

1. 用户与视图交互，触发事件。
2. 视图将事件发送给控制器。
3. 控制器接收事件并进行处理，可能需要从模型中获取数据或者调用模型的方法进行业务逻辑处理。
4. 控制器将处理结果返回给视图。
5. 视图根据控制器返回的结果更新界面。

具体来说，MVC 的三个组件的作用如下：

1. 模型（Model）：模型表示应用程序的数据和业务逻辑，负责对数据进行处理、存储和检索。它提供了数据接口，供控制器和视图使用。
2. 视图（View）：视图表示应用程序的用户界面，负责展示数据、接收用户输入、响应用户操作。它是用户与应用程序交互的窗口，可以是一个页面、一个组件或者一个控件。
3. 控制器（Controller）：控制器是模型和视图之间的中介，负责接收用户输入、处理业务逻辑、更新模型和更新视图。它负责协调和管理视图和模型之间的通信，将用户输入转换为对模型的操作，并将模型的更新通知视图更新界面。

通过这种工作流程，MVC 可以实现代码的分离和解耦，使得代码更加清晰、可维护和可扩展。同时，MVC 的工作流程也提供了一种可重用的设计模式，能够在不同的应用程序中使用。

## Spring MVC工作流程

![image-20230217202926943](https://wrxinyue.oss-cn-hongkong.aliyuncs.com/img/image-20230217202926943.png)

1. 用户发送请求至前端控制器 DispatcherServlet。
2. DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。
3. 处理器映射器找到具体的处理器（可以根据 XML 配置、注解进行查找），生成处理器及处理器拦截器（如果有则生成并返回给 DispatcherServlet）。
4. DispatcherServlet 调用 HandlerAdapter 处理器适配器。
5. HandlerAdapter 经过适配调用具体的处理器（Controller，也叫后端控制器）。
6. Controller 执行完成返回 ModelAndView。
7. HandlerAdapter 将 Controller 执行结果 ModelAndView 返回给 DispatcherServlet。
8. DispatcherServlet 将 ModelAndView 传给 ViewResolver 视图解析器。
9. ViewResolver 解析后返回具体 View。
10. DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。
11. DispatcherServlet 响应用户。



Spring MVC 是基于 MVC 模式的 Web 框架，用于构建 Web 应用程序。Spring MVC 的工作流程如下：

1. 用户发送请求：用户在浏览器中发送请求，请求会被发送到服务器端的 DispatcherServlet。
2. DispatcherServlet 接收请求：DispatcherServlet 是 Spring MVC 中的核心组件，用于接收请求并将请求分发到相应的处理器。
3. 处理器映射器解析请求：处理器映射器（HandlerMapping）用于解析请求并确定请求对应的处理器，它会将请求映射到一个或多个处理器。
4. 处理器适配器调用处理器：处理器适配器（HandlerAdapter）会调用处理器对请求进行处理，处理器可以是一个控制器（Controller）、一个服务类（Service）或其他组件。
5. 处理器处理请求：处理器对请求进行处理，并生成相应的模型和视图对象。
6. 视图解析器解析视图：视图解析器（ViewResolver）用于解析视图，根据处理器返回的视图名称和视图类型确定最终的视图对象。
7. 视图渲染：视图将模型数据渲染到 HTML、JSON、XML 或其他类型的响应体中。
8. 响应结果发送给客户端：响应结果被发送回客户端，客户端接收到响应结果并显示在浏览器中。

通过这个工作流程，Spring MVC 可以实现请求的处理、视图的渲染和响应的发送，实现了分离关注点，使得应用程序的开发更加模块化，代码也更加清晰和易于维护。同时，Spring MVC 提供了丰富的扩展点和定制选项，可以方便地满足不同应用程序的需求。

## SSM工作流程

1. 用户发送请求：用户在浏览器中发送请求，请求会被发送到服务器端的 DispatcherServlet。
2. DispatcherServlet 接收请求：DispatcherServlet 是 Spring MVC 中的核心组件，用于接收请求并将请求分发到相应的处理器。
3. 处理器映射器解析请求：处理器映射器（HandlerMapping）用于解析请求并确定请求对应的处理器，它会将请求映射到一个或多个处理器。
4. 处理器适配器调用处理器：处理器适配器（HandlerAdapter）会调用处理器对请求进行处理，处理器可以是一个控制器（Controller）、一个服务类（Service）或其他组件。
5. 处理器处理请求：处理器对请求进行处理，可以通过调用服务类等方式获取业务数据并进行处理，生成相应的模型和视图对象。
6. MyBatis 数据访问：MyBatis 是一个 ORM 框架，它可以将 Java 对象映射到数据库表中，使得开发人员可以通过对象的方式访问数据库。在 SSM 中，处理器可以通过调用 MyBatis DAO 层的方法来访问数据库，获取数据并进行处理。
7. 视图解析器解析视图：视图解析器（ViewResolver）用于解析视图，根据处理器返回的视图名称和视图类型确定最终的视图对象。
8. 视图渲染：视图将模型数据渲染到 HTML、JSON、XML 或其他类型的响应体中。
9. 响应结果发送给客户端：响应结果被发送回客户端，客户端接收到响应结果并显示在浏览器中。

通过这个工作流程，SSM 框架可以实现请求的处理、数据库访问、视图的渲染和响应的发送，实现了分离关注点，使得应用程序的开发更加模块化，代码也更加清晰和易于维护。同时，SSM 框架提供了丰富的扩展点和定制选项，可以方便地满足不同应用程序的需求。

## VUE工作流程

1. 创建 Vue 实例：首先，我们需要通过创建 Vue 实例来启动应用程序。Vue 实例是 Vue.js 的核心，它包含了应用程序的数据和方法，以及用于将数据和方法绑定到视图上的指令。
2. 模板解析：Vue.js 使用基于 HTML 的模板语法，将模板解析成 Virtual DOM 树。
3. 数据绑定：Vue.js 使用双向数据绑定机制，可以将模型数据和视图保持同步。当模型数据发生变化时，视图会自动更新，反之亦然。
4. 编译模板：Vue.js 将模板编译成渲染函数，这个函数可以将 Virtual DOM 节点渲染成真正的 DOM 节点，并将模板中的指令转换为对应的 JavaScript 代码。
5. 渲染视图：Vue.js 使用 Virtual DOM 技术，将模板中的数据和方法渲染到真实的 DOM 上。
6. 监听事件：Vue.js 使用指令和事件处理器，可以实现用户交互的响应，例如点击按钮、输入文本等操作。
7. 更新数据：当用户交互或其他事件发生时，Vue.js 会自动更新模型数据，触发重新渲染视图。这个过程中，Vue.js 会根据依赖关系自动进行优化，只更新必要的组件，提高性能。

通过这个工作流程，Vue.js 可以实现高效的视图渲染、双向数据绑定和组件化开发，使得应用程序的开发更加快速和灵活。同时，Vue.js 提供了丰富的插件和组件库，可以方便地扩展和定制应用程序，满足不同应用程序的需求。



## 总结

* 这三者都是框架模式，它们设计的目标都是为了解决Model和View的耦合问题。
* MVC模式出现较早主要应用在后端，如Spring MVC、ASP.NET MVC等，在前端领域的早期也有应用，如
  Backbone.js。。它的优点是分层清晰，缺点是数据流混乱，灵活性带来的维护性问题。
* MVP模式在是MVC的进化形式，Presenter作为中间层负责M通信，解决了两者耦合问题，但P层过于臃肿会
  导致维护问题。
* MWM模式在前端领域有广泛应用，它不仅解决MV耦合问题，还同时解决了维护两者映射关系的大量繁杂代
  码和DOM操作代码，在提高开发效率、可读性同时还保持了优越的性能表现。



# Re ferences

[java进阶之三层架构+MVC - 灰信网](https://www.freesion.com/article/3175878285/)

[Spring, 3-Tier-Architecture](https://gngsn.tistory.com/84)

[mvc，mvp，mvvm 的区别](https://www.bilibili.com/video/BV1Ji4y1U7Y1/)

[Web开发的历史发展技术演变-阿里云开发者社区](https://developer.aliyun.com/article/770897)

[前端框架模式的变迁](https://toutiao.io/posts/fklq1v/preview)