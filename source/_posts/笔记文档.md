工作思路流程：


1. 先建实体类model（面向对象思想）
2. 根据后端Controller写Api接口
3. 做好最基本的画面（大体骨架），然后调接口


微信小程序整体思路流程：
list - index 页面
```js
        isDrawLine="{{index+1 !== addressList.length}}"  //是否需要底部边线

        extra-space="{{extraSpace}}"  //额外空间

        class-prefix="ym"  //样式前缀

        address="{{address}}"  //地址信息

        data-id="{{address.id}}"  //地址ID

        bind:onSelect="selectHandle"  //选中地址事件

        bind:onDelete="deleteAddressHandle"  //删除地址事件

        bind:onEdit="editAddressHandle"  //编辑地址事件
```

```html
      <!-- 添加收货地址 -->

      <view class="address-btn {{addressList.length >= 20 ? 'btn-default':''}}" bind:tap="createHandle">

        <t-icon name="add" size="48rpx" color="#fff" t-class="custom-class" />

        <text>添加收货地址</text>

      </view>
```
editAddressHandle和createHandle都是用来调用index.js的函数，只是方式不同

调用之后会执行路由跳转：
```js
wx.navigateTo({ url: `/pages/usercenter/address/edit/index?id=${id}` });
```

edit 的 index.js  会根据是否有id值，进行不同的操作


首先会在onLoad执行参数，并传入options即id对象，如果id存在就为编辑地址否则为添加新地址
```js
  /** 页面加载时执行 */

  onLoad(options) {

    const { id } = options;

    wx.setNavigationBarTitle({

      title: id ? '编辑地址' : '添加新地址',

    });

    this.init(id);

  },

  /** 当页面卸载时执行 */

  onUnload() {

    if (!this.hasSava) {

      rejectAddress();

    }

  },

  /** 初始化hasSava变量 */

  hasSava: false,

```

初始化id函数，并传入id对象进行判断是否存在，如果存在就获取当前地址信息
```js
  /** 初始化函数，根据传入的id获取地址详情 */

  init(id) {

    if (id) {

      /** 获取地址详情 */

      this.getAddressDetail(Number(id));

    }

  },
```

当在该页面进项表单提交时，会执行formSubmit()函数

``` tree

usercenter
	- edit 业务逻辑编辑
	- list 列表显示

```


目前问题

我的：
1. 翻页问题
2. 样式
3. 三天调试
4.  小程序Ui, 短信
5. Token
6. 登录和，检索


实现复制，

复制的树id变成新增的树id，有多表

bi -arm

后端是master

前段是dev


## 学习Vue指定计划：

要点首先知道自己要学习什么，目标是什么。首先目标已经很清楚了。

### 目标

学会前端Vue，并找到工作

### 注意事项

学习Vue绝对不是看完Vue视频就是学会，首先一点我是不推荐看Vue入门视频的。
为什么我不推荐看视频，在Vue作者说过学习Vue最好的方式就是看**官方文档**一边练习做**项目**
这对小白来说这可能很难，但是如果你养成了看官方文档进行学习的习惯，你的知识点远超于培训班将的知识点，自学是自己最好的老师。其次如果看官方文档学习有利于学习新技术，毕竟基于TypeScript和Vue3的视频教程，培训班基本不可能放出来。因为这是一个非常新的技术栈，培训班的目的只是为了赚钱，不可能花费大量金钱去请一个会新技术栈的大能讲师。

### 学习要点



## 工作要点

要求：实现点击感叹号的一个图标，再图标对应窗口关闭时，把tree的所有数据修改Id并进行保存

实现：
1. 首选确定tree的数据位置，并进行打印获取
2. 确定tree的数据内容





## 修改建议

1. 删除没有反悔选项
2. 删除项目应该加个退出
3. 重写异常
4. 增加返回条件


首先，您需要从URL中解析“projectId”。在JavaScript中，可以使用`URLSearchParams`对象来实现。您可以在`closeTrigger`方法中添加以下代码来获取“projectId”：

javascript

`// 获取URL的查询参数 const queryParams = new URLSearchParams(window.location.search); // 从查询参数中获取projectId const projectId = queryParams.get("projectId");`

然后，您可以将获取到的`projectId`赋值给`pmProjectUpdate.targetId`。以下是更新后的`closeTrigger`方法：

javascript

`/** ep-info-filled 关闭事件 */ const closeTrigger = async () => {     // 获取URL的查询参数     const queryParams = new URLSearchParams(window.location.search);     // 从查询参数中获取projectId     const projectId = queryParams.get("projectId");      const pmProjectUpdate = new PmProjectUpdate()     pmProjectUpdate.copyId = Number(form.id)     // 将获取到的projectId赋值给targetId     pmProjectUpdate.targetId = Number(projectId)     console.log('Selected project ID:', pmProjectUpdate)     const pmProjectMemberResult = await pmProjectApi.copyTemplate(pmProjectUpdate) }`

这样，当您调用`closeTrigger`方法时，将从URL中获取“projectId”并赋值给`pmProjectUpdate.targetId`。


```java
package cn.iocoder.yudao.module.biz.service.pmproject;  
  
import cn.iocoder.yudao.framework.common.pojo.PageResult;  
import cn.iocoder.yudao.module.biz.controller.admin.pmproject.vo.*;  
import cn.iocoder.yudao.module.biz.convert.pmproject.PmProjectConvert;  
import cn.iocoder.yudao.module.biz.dal.dataobject.pmproject.PmProjectDO;  
import cn.iocoder.yudao.module.biz.dal.dataobject.srmarea.SrmAreaDO;  
import cn.iocoder.yudao.module.biz.dal.mysql.pmproject.PmProjectMapper;  
import org.springframework.stereotype.Service;  
import org.springframework.validation.annotation.Validated;  
  
import javax.annotation.Resource;  
import java.util.ArrayList;  
import java.util.Collection;  
import java.util.List;  
  
import static cn.iocoder.yudao.framework.common.exception.util.ServiceExceptionUtil.exception;  
import static cn.iocoder.yudao.module.biz.enums.ErrorCodeConstants.PM_PROJECT_NOT_EXISTS;  
  
/**  
 * 项目管理 Service 实现类  
 *  
 * @author 芋道源码  
 */  
@Service  
@Validated  
public class PmProjectServiceImpl implements PmProjectService {  
  
    @Resource  
    private PmProjectMapper pmProjectMapper;  
  
    @Override  
    public Long createPmProject(PmProjectCreateReqVO createReqVO) {  
        // 插入  
        PmProjectDO pmProject = PmProjectConvert.INSTANCE.convert(createReqVO);  
        pmProjectMapper.insert(pmProject);  
        // 返回  
        return pmProject.getId();  
    }  
  
    @Override  
    public void updatePmProject(PmProjectUpdateReqVO updateReqVO) {  
        // 校验存在  
        this.validatePmProjectExists(updateReqVO.getId());  
        // 更新  
        PmProjectDO updateObj = PmProjectConvert.INSTANCE.convert(updateReqVO);  
        pmProjectMapper.updateById(updateObj);  
    }  
  
    @Override  
    public void deletePmProject(Long id) {  
        // 校验存在  
        this.validatePmProjectExists(id);  
        // 删除  
        pmProjectMapper.deleteById(id);  
    }  
  
    private void validatePmProjectExists(Long id) {  
        if (pmProjectMapper.selectById(id) == null) {  
            throw exception(PM_PROJECT_NOT_EXISTS);  
        }  
    }  
  
    @Override  
    public PmProjectDO getPmProject(Long id) {  
        return pmProjectMapper.selectById(id);  
    }  
  
    @Override  
    public List<PmProjectDO> getPmProjectList(Collection<Long> ids) {  
        if (ids.size() > 0) {  
            return pmProjectMapper.selectBatchIds(ids);  
        } else {  
            return pmProjectMapper.selectList();  
        }  
    }  
  
    @Override  
    public List<PmProjectDO> getProjectListByProjectGroupId(Long projectGroupId) {  
        return pmProjectMapper.selectList(PmProjectDO::getProjectGroupId,projectGroupId);  
    }  
  
    @Override  
    public PageResult<PmProjectDO> getPmProjectPage(PmProjectPageReqVO pageReqVO) {  
        return pmProjectMapper.selectPage(pageReqVO);  
    }  
  
    @Override  
    public List<PmProjectDO> getPmProjectList(PmProjectExportReqVO exportReqVO) {  
        return pmProjectMapper.selectList(exportReqVO);  
    }  
  
    @Override  
    public Long copyPmTemplate(PmCopyTemplateReqVO templateReqVO, List<SrmAreaDO> srmAreaDOList) {  
        Long CopyId = templateReqVO.getCopyId();  
        Long TargetId = templateReqVO.getTargetId();  
  
        /** 用于记录数上的节点 */  
        Long identifying1 = 100L;  
        Long identifying2 = 100L;  
  
        // 找到根节点  
        Node root = null;  
        MultiwayTree tree = null;  
        for (SrmAreaDO data : new ArrayList<>(srmAreaDOList)) {  
            if (data.getParentId() == 0) {  
                root = new Node(data);  
                // 创建多叉树  
                tree = new MultiwayTree(root);  
            } else if (data.getPath() == null) {  
                srmAreaDOList.remove(data);  
                System.out.println("id为：" + data.getId() + "节点的值为null");  
            } else {  
                // 添加所有其他节点  
                tree.addNode(data.getParentId(), data);  
            }  
        }  
        tree.traverseTree(tree.getRoot(), node -> System.out.println(node.getData()));  
        System.out.println("==========================================================================================");  
  
        /** 更新项目Id */  
        updateProjectIdInTree(tree.getRoot(), TargetId);  
  
        for (SrmAreaDO data : srmAreaDOList) {  
            /** 节点更新 */  
            Long oldId = data.getId();  
            Long newId = identifying;  
  
            Node nodeToUpdate = tree.findNode(oldId);  
  
            if (newId.equals(srmAreaDOList.get(srmAreaDOList.size() - 1).getId() + 1)) {  
                newId = 0L;  
            }  
            if (data.getId().equals(0)) {  
                break;  
            }  
            if (nodeToUpdate != null) {  
                // 更新节点的 id 和 projectId                data.setId(newId);  
                data.setProjectId(TargetId);  
  
                // 更新节点  
                tree.updateNode(oldId, data);  
  
                // 获取更新后节点的路径并更新到新节点  
                Node updatedNode = tree.findNode(newId);  
                String path = tree.getPath(updatedNode);  
                data.setPath(path);  
            }  
            identifying++;  
        }  
  
        // 打印更新后的节点数据，检查 projectId 是否已更改  
        tree.traverseTree(tree.getRoot(), node -> System.out.println(node.getData()));  
  
        return Long.valueOf("12");  
    }  
  
//    public static void updatePathInTree(Node node, String parentPath) {  
//        if (node != null) {  
//            // 检查父路径是否为 "0"，如果是，则保持路径不变，否则按照正常流程更新路径  
//            String path;  
//            if ("0".equals(parentPath)) {  
//                path = "0," + node.getData().getId();  
//            } else {  
//                path = parentPath == null ? String.valueOf(node.getData().getId()) : parentPath + "," + node.getData().getId();  
//            }  
//            node.getData().setPath(path);  
//            for (Node child : node.getChildren()) {  
//                updatePathInTree(child, path);  
//            }  
//        }  
//    }  
  
    /** 更新节点projectId */  
    public static void updateProjectIdInTree(Node node, Long newProjectId) {  
        if (node == null) {  
            return;  
        }  
  
        // 更新当前节点的 projectId        SrmAreaDO data = node.getData();  
        data.setProjectId(newProjectId);  
  
        // 递归更新子节点  
        for (Node child : node.getChildren()) {  
            updateProjectIdInTree(child, newProjectId);  
        }  
    }  
  
    //        for (SrmAreaDO data : srmAreaDOList) {  
//            /** 节点更新 *///            Long oldId = data.getId();  
//            Long newId = identifying;  
//  
//            // 根据oldId找到要更新的节点  
//            SrmAreaDO newData = data;  
//            Node oldNode = tree.findNode(oldId);  
//  
//            if (newData != null) {  
//                // 更新节点的 id//                newData.setId(newId);  
//                // 替换节点  
//                tree.replaceNode(oldId, newData);  
//  
//                // 查找新节点  
//                Node newNode = tree.findNode(newId);  
//                // 查找新节点的父节点路径  
//                Node parentNode = tree.findParentNode(newId, tree.getRoot());  
//                String newParentPath = parentNode != null ? parentNode.getData().getPath() : "0";  
//                // 更新受影响的节点的 path//                tree.updatePathInTree(newNode, data.getPath(), newParentPath, true);  
//            }  
//            identifying++;  
//        }  
  
  
    //    private static void updatePathInTree(Node node, String parentPath) {//        if (node != null) {  
//            String path = parentPath == null ? String.valueOf(node.getData().getId()) : parentPath + "," + node.getData().getId();  
//            node.getData().setPath(path);  
//            for (Node child : node.getChildren()) {  
//                updatePathInTree(child, path);  
//            }  
//        }  
//    }  
  
    // 查找要复制的节点  
//        Node foundNode = tree.findNode(CopyId);  
//        if (foundNode != null) {  
//            System.out.println("找到节点：" + foundNode.getData());  
//        } else {  
//            System.out.println("节点不存在");  
//        }  
  
  
    // 更新所有节点的 path//        updatePathInTree(tree.getRoot(), null);  
  
    // 使用 traverseTree 方法打印所有节点的数据，检查 path 是否已更新  
//        tree.traverseTree(tree.getRoot(), node -> System.out.println(node.getData()));  
  
  
    /** 更新当前节点的 path */  
//    public static void updatePathInTree(Node node, String parentPath) {  
//        if (node == null) {  
//            return;  
//        }  
//  
//        // 更新当前节点的 path//        SrmAreaDO data = node.getData();  
//        String newPath = parentPath == null ? Integer.toString(Math.toIntExact(data.getId())) : parentPath + "," + data.getId();  
//        data.setPath(newPath);  
//  
//        // 递归更新子节点  
//        for (Node child : node.getChildren()) {  
//            updatePathInTree(child, newPath);  
//        }  
//    }  
  
  
//    private List<SrmAreaDO> srmAreaDOList = new ArrayList<>();  
//  
//    public SrmAreaDO findById(Long id) {  
//        return srmAreaDOList.stream()  
//                .filter(area -> area.getId().equals(id))  
//                .findFirst()  
//                .orElse(null);  
//    }  
//  
//    public List<SrmAreaDO> findByParentId(Long parentId) {  
//        return srmAreaDOList.stream()  
//                .filter(area -> area.getParentId().equals(parentId))  
//                .collect(Collectors.toList());  
//    }  
//  
//    public List<SrmAreaDO> findChildren(Long parentId) {  
//        return findByParentId(parentId);  
//    }  
//  
//    public List<SrmAreaDO> findDescendants(Long parentId) {  
//        List<SrmAreaDO> descendants = new ArrayList<>();  
//        for (SrmAreaDO child : findChildren(parentId)) {  
//            descendants.add(child);  
//            descendants.addAll(findDescendants(child.getId()));  
//        }  
//        return descendants;  
//    }  
//  
//    // 添加  
//    public void add(SrmAreaDO newArea) {  
//        srmAreaDOList.add(newArea);  
//    }  
//  
//    // 修改  
//    public void update(SrmAreaDO updatedArea) {  
//        for (int i = 0; i < srmAreaDOList.size(); i++) {  
//            if (srmAreaDOList.get(i).getId().equals(updatedArea.getId())) {  
//                srmAreaDOList.set(i, updatedArea);  
//                break;  
//            }  
//        }  
//    }  
//  
//    // 删除  
//    public void delete(Long id) {  
//        SrmAreaDO areaToDelete = findById(id);  
//        if (areaToDelete != null) {  
//            List<SrmAreaDO> descendants = findDescendants(areaToDelete.getId());  
//            srmAreaDOList.remove(areaToDelete);  
//            srmAreaDOList.removeAll(descendants);  
//        }  
//    }  
  
//    /** 树的根节点 *///    private Node root = new Node(0);  
//    /** 用于记录数上的节点 *///    private int identifying = 1;  
//    /** 用于遍历树的指针路过的节点的个数 *///    private int index = 0;  
  
    /** 类型转换 */  
//    private List<Node> convertToNodeList(List<SrmAreaRespVO> srmAreaRespVOList) {  
//        List<Node> nodeList = new ArrayList<>();  
//        for (SrmAreaRespVO srmAreaRespVO : srmAreaRespVOList) {  
//            Node node = new Node(identifying++, srmAreaRespVO);  
//            nodeList.add(node);  
//        }  
//        return nodeList;  
//    }  
  
    // 添加  
//    private void add(Long parentId, SrmAreaRespVO data, List<Node> list) {  
//        // 如果父节点为0  
//        if (parentId == 0) {  
//            Node newNode = new Node(identifying++, data);  
//            this.root.nodes.add(newNode);  
//        } else {    // 判空  
//            if (list.size() == 0) {  
//                return;  
//            }  
//            for (Node item: list) {  
//                // 找到父节点  
//                if (item.getId() == parentId) {  
//                    Node newNode = new Node(identifying++, data);  
//                    // 节点添加  
//                    item.nodes.add(newNode);  
//                    break;  
//                } else {  
//                    add(parentId, data, item.nodes);  
//                }  
//            }  
//        }  
//    }  
  
    // 循环Tree  
//    private void list(List<Node> list) {  
//        index ++;  
//        if (index == identifying) {  
//            return;  
//        }  
//        for (Node item : list) {  
//            System.out.println(item.getData());  
//            if(item.nodes.size() == 0) {  
//                continue;  
//            } else {  
//                list(item.nodes);  
//            }  
//            System.out.println("\t");  
//        }  
//    }  
  
  
//    private void traverseSrmAreaRespVOList(List<SrmAreaDO> srmAreaDOList, Long TargetId) {  
//  
//        List<SrmAreaDO> srmAreaDOListReutrn = new ArrayList<>();  
//        SrmAreaDO srmAreaDO1 = new SrmAreaDO();  
//        Long id = srmAreaDOList.get(srmAreaDOList.size()).getId();  
//        Long subId;  
//  
//        for (SrmAreaDo srmAreaDo : srmAreaDOList) {  
//            id++;  
//            srmAreaDO1.setProjectId(TargetId);  
//            for (int i = 0; i < srmAreaDOList.size(); i++) {  
//                String[] parts = srmAreaDOList.get(i).getPath().split(",");  
//                String[] numberParts = new String[parts.length];  
//                StringBuffer stringPart = new StringBuffer();  
//                for (int j = 0; j < parts.length; j++) {  
//                    numberParts[j] = parts[i];  
//                }  
//                for (int j = 0; j < numberParts.length; j++) {  
//                    if (numberParts[j].equals("0")) {  
//                        stringPart.append("0");  
//                    } else if (numberParts[j].equals("null")) {  
//                        stringPart.append("null");  
//                    } else if (numberParts[j] == null) {  
//                    }  
//                }  
//            }  
//        }  
//    }  
  
}
```


框架：ui库：WeUI，有赞的vantUI
框架：腾讯的WePY，uni-app，美团的mpvue
react可以使用阿里的remax，京东的taro
跨端开发支持，uniapp，remax taro，chameleon


启动

dev:h5


https://gitee.com/myhomes2022/gold-mall-web
用户名：myhomes2022
密码：myhomes594188